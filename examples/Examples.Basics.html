<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Examples.Basics</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<div class="code">
<span class="comment">(**********************************************************************)</span><br/>
<span class="comment">(*&nbsp;Equations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;Copyright&nbsp;(c)&nbsp;2009-2021&nbsp;Matthieu&nbsp;Sozeau&nbsp;&lt;matthieu.sozeau@inria.fr&gt;&nbsp;*)</span><br/>
<span class="comment">(**********************************************************************)</span><br/>
<span class="comment">(*&nbsp;This&nbsp;file&nbsp;is&nbsp;distributed&nbsp;under&nbsp;the&nbsp;terms&nbsp;of&nbsp;the&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;GNU&nbsp;Lesser&nbsp;General&nbsp;Public&nbsp;License&nbsp;Version&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="comment">(**********************************************************************)</span><br/>
</div>

<div class="doc">
<a id="lab1"></a><h1 class="section">Basic examples</h1>


<div class="paragraph"> </div>

  This file containts various examples demonstrating the features of Equations.
  If running this interactively you can ignore the printing
  and hide directives which are just used to instruct coqdoc. 
</div>
<div class="code">

<br/>
#[<span class="id" title="var">warnings</span>="-deprecated-library-file-since-8.20"]<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Stdlib</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Program</span> <span class="id" title="var">Bvector</span> <span class="id" title="var">List</span> <span class="id" title="var">Relations</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="keyword">Equations</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="keyword">Equations</span> <span class="id" title="var">Signature</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Stdlib</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Utf8</span>.<br/>

<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Keyed</span> <span class="id" title="var">Unification</span>.<br/>

<br/>
</div>

<div class="doc">
Just pattern-matching 
</div>
<div class="code">
<span class="id" title="keyword">Equations</span> <span class="id" title="var">neg</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> :=<br/>
<span class="id" title="var">neg</span> <span class="id" title="var">true</span> := <span class="id" title="var">false</span> ;<br/>
<span class="id" title="var">neg</span> <span class="id" title="var">false</span> := <span class="id" title="var">true</span>.<br/>

<br/>
</div>

<div class="doc">
A proof using the functional elimination principle derived for <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#neg"><span class="id" title="definition">neg</span></a></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">neg_inv</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span>, <span class="id" title="var">neg</span> (<span class="id" title="var">neg</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>. <span class="id" title="var">funelim</span> (<span class="id" title="var">neg</span> <span class="id" title="var">b</span>); <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Obligations</span>.<br/>

<br/>
</div>

<div class="doc">
One can use equations similarly to Program or the <span class="inlinecode"><span class="id" title="tactic">refine</span></span> tactic,
      putting underscores <span class="inlinecode"><span class="id" title="var">_</span></span> for subgoals to be filled separately using
      the tactic mode. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Equations</span>? <span class="id" title="var">f</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">f</span> 0 := 42 ;<br/>
&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="keyword">with</span> <span class="id" title="var">f</span> <span class="id" title="var">m</span> :=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="var">IH</span> := <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;}.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">IH</span>. <span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="keyword">Obligations</span>.<br/>

<br/>
</div>

<div class="doc">
Structural recursion and use of the <span class="inlinecode"><span class="id" title="keyword">with</span></span> feature to look at the result
    of a recursive call (here with a trivial pattern-matching. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">List</span>.<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">app_with</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">l</span> <span class="id" title="var">l'</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="var">app_with</span> <span class="id" title="var">nil</span> <span class="id" title="var">l</span> := <span class="id" title="var">l</span> ;<br/>
<span class="id" title="var">app_with</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v</span>) <span class="id" title="var">l</span> <span class="id" title="keyword">with</span> <span class="id" title="var">app_with</span> <span class="id" title="var">v</span> <span class="id" title="var">l</span> ⇒ {<br/>
&nbsp;&nbsp;| <span class="id" title="var">vl</span> := <span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">vl</span> }.<br/>

<br/>
</div>

<div class="doc">
Structurally recursive function on natural numbers, with inspection of a recursive
    call result. We use <span class="inlinecode"><span class="id" title="tactic">auto</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="var">arith</span></span> to discharge the obligations. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Local Obligation</span> <span class="id" title="keyword">Tactic</span> := <span class="id" title="tactic">program_simpl</span> ; <span class="id" title="tactic">try</span> <span class="id" title="var">CoreTactics.solve_wf</span> ; <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">arith</span>.<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">equal</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : { <span class="id" title="var">n</span> = <span class="id" title="var">m</span> } + { <span class="id" title="var">n</span> ≠ <span class="id" title="var">m</span> } :=<br/>
<span class="id" title="var">equal</span> <span class="id" title="var">O</span> <span class="id" title="var">O</span> := <span class="id" title="var">in_left</span> ;<br/>
<span class="id" title="var">equal</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) <span class="id" title="keyword">with</span> <span class="id" title="var">equal</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> ⇒ {<br/>
&nbsp;&nbsp;<span class="id" title="var">equal</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) (<span class="id" title="var">S</span> ?(<span class="id" title="var">n</span>)) (<span class="id" title="tactic">left</span> <span class="id" title="var">eq_refl</span>) := <span class="id" title="tactic">left</span> <span class="id" title="var">eq_refl</span> ;<br/>
&nbsp;&nbsp;<span class="id" title="var">equal</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) (<span class="id" title="var">S</span> <span class="id" title="var">m</span>) (<span class="id" title="tactic">right</span> <span class="id" title="var">p</span>) := <span class="id" title="var">in_right</span> } ;<br/>
<span class="id" title="var">equal</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> := <span class="id" title="var">in_right</span>.<br/>

<br/>
</div>

<div class="doc">
Pattern-matching on the indexed equality type. 
</div>
<div class="code">
<span class="id" title="keyword">Equations</span> <span class="id" title="var">eq_sym</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span>) : <span class="id" title="var">y</span> = <span class="id" title="var">x</span> :=<br/>
<span class="id" title="var">eq_sym</span> <span class="id" title="var">x</span> <span class="id" title="var">_</span> <span class="id" title="var">eq_refl</span> := <span class="id" title="var">eq_refl</span>.<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">eq_trans</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span>) (<span class="id" title="var">q</span> : <span class="id" title="var">y</span> = <span class="id" title="var">z</span>) : <span class="id" title="var">x</span> = <span class="id" title="var">z</span> :=<br/>
<span class="id" title="var">eq_trans</span> <span class="id" title="var">x</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">eq_refl</span> <span class="id" title="var">eq_refl</span> := <span class="id" title="var">eq_refl</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">vector</span> := <span class="id" title="var">Vector.t</span>.<br/>
<span class="id" title="keyword">Derive</span> <span class="id" title="var">Signature</span> <span class="id" title="keyword">for</span> <span class="id" title="var">eq</span> <span class="id" title="var">vector</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">KAxiom</span>.<br/>

<br/>
</div>

<div class="doc">
By default we disallow the K axiom, but it can be set. 
<div class="paragraph"> </div>

 In this case the following definition fails as <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#KDec.K"><span class="id" title="definition">K</span></a></span> is not derivable on type <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#well_founded_recursion_and_auxiliary_function.A"><span class="id" title="variable">A</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="keyword">Equations</span> <span class="id" title="var">K</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">x</span> = <span class="id" title="var">x</span> → <span class="id" title="keyword">Type</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">P</span> <span class="id" title="var">eq_refl</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">x</span> = <span class="id" title="var">x</span>) : <span class="id" title="var">P</span> <span class="id" title="var">H</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">K</span> <span class="id" title="var">x</span> <span class="id" title="var">P</span> <span class="id" title="var">p</span> <span class="id" title="var">eq_refl</span> := <span class="id" title="var">p</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Set</span> <span class="id" title="keyword">Equations</span> <span class="id" title="var">With</span> <span class="id" title="var">UIP</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Axiom</span> <span class="id" title="var">uip</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span>, <span class="id" title="var">UIP</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Local Existing Instance</span> <span class="id" title="var">uip</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Equations</span> <span class="id" title="var">K_ax</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">x</span> = <span class="id" title="var">x</span> → <span class="id" title="keyword">Type</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">P</span> <span class="id" title="var">eq_refl</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">x</span> = <span class="id" title="var">x</span>) : <span class="id" title="var">P</span> <span class="id" title="var">H</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">K_ax</span> <span class="id" title="var">x</span> <span class="id" title="var">P</span> <span class="id" title="var">p</span> <span class="id" title="var">eq_refl</span> := <span class="id" title="var">p</span>.<br/>

<br/>
</div>

<div class="doc">
The definition is however using an axiom equivalent to <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#KDec.K"><span class="id" title="definition">K</span></a></span>, so it cannot reduce
      on closed or open terms. 
</div>
<div class="code">
<span class="id" title="keyword">End</span> <span class="id" title="var">KAxiom</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">KDec</span>.<br/>
</div>

<div class="doc">
However, types enjoying a provable instance of the <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#KDec.K"><span class="id" title="definition">K</span></a></span> principle are fine using the <span class="inlinecode"><span class="id" title="var">With</span></span> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Prop.Classes.html#UIP"><span class="id" title="class">UIP</span></a></span>
      option. Note that the following definition does *not* reduce according to its single clause
      on open terms, it instead computes using the decidable equality proof on natural numbers. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Set</span> <span class="id" title="keyword">Equations</span> <span class="id" title="var">With</span> <span class="id" title="var">UIP</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="keyword">Equations</span> <span class="id" title="var">K</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">x</span> = <span class="id" title="var">x</span> → <span class="id" title="keyword">Type</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">P</span> <span class="id" title="var">eq_refl</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">x</span> = <span class="id" title="var">x</span>) : <span class="id" title="var">P</span> <span class="id" title="var">H</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">K</span> <span class="id" title="var">x</span> <span class="id" title="var">P</span> <span class="id" title="var">p</span> <span class="id" title="var">eq_refl</span> := <span class="id" title="var">p</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Equations</span> <span class="id" title="var">K</span> (<span class="id" title="var">x</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">x</span> = <span class="id" title="var">x</span> → <span class="id" title="keyword">Type</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">P</span> <span class="id" title="var">eq_refl</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">x</span> = <span class="id" title="var">x</span>) : <span class="id" title="var">P</span> <span class="id" title="var">H</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">K</span> <span class="id" title="var">x</span> <span class="id" title="var">P</span> <span class="id" title="var">p</span> <span class="id" title="var">eq_refl</span> := <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Print</span> <span class="id" title="keyword">Assumptions</span> <span class="id" title="var">K</span>. <span class="comment">(*&nbsp;Closed&nbsp;under&nbsp;the&nbsp;global&nbsp;context&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">KDec</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" title="keyword">with</span></span> construct allows to pattern-match on an intermediary computation.
    The "|" syntax provides a shortcut to repeating the previous patterns. 
</div>
<div class="code">
<span class="id" title="keyword">Section</span> <span class="id" title="var">FilterDef</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">A</span> → <span class="id" title="var">bool</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Equations</span> <span class="id" title="var">filter</span> (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">filter</span> <span class="id" title="var">nil</span> := <span class="id" title="var">nil</span> ;<br/>
&nbsp;&nbsp;<span class="id" title="var">filter</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">l</span>) <span class="id" title="keyword">with</span> <span class="id" title="var">p</span> <span class="id" title="var">a</span> ⇒ {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> := <span class="id" title="var">a</span> :: <span class="id" title="var">filter</span> <span class="id" title="var">l</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> := <span class="id" title="var">filter</span> <span class="id" title="var">l</span> }.<br/>

<br/>
</div>

<div class="doc">
By default, equations makes definitions opaque after definition,
      to avoid spurious unfoldings, but this can be reverted on a case by case
      basis, or using the global <span class="inlinecode"><span class="id" title="keyword">Set</span></span> <span class="inlinecode"><span class="id" title="keyword">Equations</span></span> <span class="inlinecode"><span class="id" title="keyword">Transparent</span></span> option. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Global Transparent</span> <span class="id" title="var">filter</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">FilterDef</span>.<br/>

<br/>
</div>

<div class="doc">
We define inclusion of a list in another one, to specify the behavior of <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#filter"><span class="id" title="definition">filter</span></a></span> 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">incl</span> {<span class="id" title="var">A</span>} : <span class="id" title="var">relation</span> (<span class="id" title="var">list</span> <span class="id" title="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">stop</span> : <span class="id" title="var">incl</span> <span class="id" title="var">nil</span> <span class="id" title="var">nil</span> <br/>
| <span class="id" title="var">keep</span> {<span class="id" title="var">x</span> : <span class="id" title="var">A</span>} {<span class="id" title="var">xs</span> <span class="id" title="var">ys</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>} : <span class="id" title="var">incl</span> <span class="id" title="var">xs</span> <span class="id" title="var">ys</span> → <span class="id" title="var">incl</span> (<span class="id" title="var">x</span> :: <span class="id" title="var">xs</span>) (<span class="id" title="var">x</span> :: <span class="id" title="var">ys</span>)<br/>
| <span class="id" title="var">skip</span> {<span class="id" title="var">x</span> : <span class="id" title="var">A</span>} {<span class="id" title="var">xs</span> <span class="id" title="var">ys</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>} : <span class="id" title="var">incl</span> <span class="id" title="var">xs</span> <span class="id" title="var">ys</span> → <span class="id" title="var">incl</span> (<span class="id" title="var">xs</span>) (<span class="id" title="var">x</span> :: <span class="id" title="var">ys</span>).<br/>

<br/>
</div>

<div class="doc">
Using <span class="inlinecode"><span class="id" title="keyword">with</span></span> again, we can produce a proof that the filtered list is a
    sublist of the original list. 
</div>
<div class="code">
<span class="id" title="keyword">Equations</span> <span class="id" title="var">sublist</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">A</span> → <span class="id" title="var">bool</span>) (<span class="id" title="var">xs</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">incl</span> (<span class="id" title="var">filter</span> <span class="id" title="var">p</span> <span class="id" title="var">xs</span>) <span class="id" title="var">xs</span> :=<br/>
<span class="id" title="var">sublist</span> <span class="id" title="var">p</span> <span class="id" title="var">nil</span> := <span class="id" title="var">stop</span> ;<br/>
<span class="id" title="var">sublist</span> <span class="id" title="var">p</span> (<span class="id" title="var">cons</span> <span class="id" title="var">x</span> <span class="id" title="var">xs</span>) <span class="id" title="keyword">with</span> <span class="id" title="var">p</span> <span class="id" title="var">x</span> := {<br/>
&nbsp;&nbsp;| <span class="id" title="var">true</span> := <span class="id" title="var">keep</span> (<span class="id" title="var">sublist</span> <span class="id" title="var">p</span> <span class="id" title="var">xs</span>) ;<br/>
&nbsp;&nbsp;| <span class="id" title="var">false</span> := <span class="id" title="var">skip</span> (<span class="id" title="var">sublist</span> <span class="id" title="var">p</span> <span class="id" title="var">xs</span>) }.<br/>

<br/>
</div>

<div class="doc">
Well-founded definitions: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Stdlib</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Arith</span> <span class="id" title="var">Wf_nat</span>.<br/>

<br/>
</div>

<div class="doc">
One can declare new well-founded relations using instances of the <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Prop.Classes.html#WellFounded"><span class="id" title="class">WellFounded</span></a></span> typeclass. 
</div>
<div class="code">
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Instance</span> <span class="id" title="var">wf_nat</span> : <span class="id" title="var">WellFounded</span> <span class="id" title="var">lt</span> := <span class="id" title="var">lt_wf</span>.<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Resolve</span> <span class="id" title="var">Nat.lt_succ_diag_r</span> : <span class="id" title="var">lt</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" title="tactic">by</span></span> <span class="inlinecode"><span class="id" title="keyword">wf</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#well_founded_recursion_and_auxiliary_function.lt"><span class="id" title="variable">lt</span></a></span> annotation indicates the kind of well-founded recursion we want. 
</div>
<div class="code">
<span class="id" title="keyword">Equations</span> <span class="id" title="var">testn</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> <span class="id" title="tactic">by</span> <span class="id" title="keyword">wf</span> <span class="id" title="var">n</span> <span class="id" title="var">lt</span> :=<br/>
<span class="id" title="var">testn</span> 0 := 0 ;<br/>
<span class="id" title="var">testn</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="keyword">with</span> <span class="id" title="var">testn</span> <span class="id" title="var">n</span> ⇒ {<br/>
&nbsp;&nbsp;| 0 := <span class="id" title="var">S</span> 0 ;<br/>
&nbsp;&nbsp;| (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) := <span class="id" title="var">S</span> <span class="id" title="var">n'</span> }.<br/>

<br/>
</div>

<div class="doc">
Notations for vectors 
</div>
<div class="code">
<span class="id" title="keyword">Equations</span> <span class="id" title="var">Derive</span> <span class="id" title="var">NoConfusion</span> <span class="id" title="var">NoConfusionHom</span> <span class="id" title="keyword">for</span> <span class="id" title="var">vector</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">Vector.nil</span> {<span class="id" title="var">A</span>}.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">Vector.cons</span> {<span class="id" title="var">A</span>} <span class="id" title="var">_</span> {<span class="id" title="var">n</span>}.<br/>

<br/>
<span class="id" title="keyword">Declare Scope</span> <span class="id" title="var">vect_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot; x |:| y " := (@<span class="id" title="var">Vector.cons</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">_</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 20, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>) : <span class="id" title="var">vect_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot; x |: n :| y " := (@<span class="id" title="var">Vector.cons</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">n</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 20, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>) : <span class="id" title="var">vect_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[]v" := <span class="id" title="var">Vector.nil</span> (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0) : <span class="id" title="var">vect_scope</span>.<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">vect_scope</span>.<br/>

<br/>
</div>

<div class="doc">
We can define functions by structural recursion on indexed datatypes like vectors. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">vapp</span> {<span class="id" title="var">A</span>} {<span class="id" title="var">n</span> <span class="id" title="var">m</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>) (<span class="id" title="var">w</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">m</span>) : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">vapp</span> []<span class="id" title="var">v</span> <span class="id" title="var">w</span> := <span class="id" title="var">w</span> ;<br/>
&nbsp;&nbsp;<span class="id" title="var">vapp</span> (<span class="id" title="var">Vector.cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v</span>) <span class="id" title="var">w</span> := <span class="id" title="var">a</span> |:| <span class="id" title="var">vapp</span> <span class="id" title="var">v</span> <span class="id" title="var">w</span>.<br/>

<br/>
</div>

<div class="doc">
We can also support well-founded recursion on indexed datatypes. 
<div class="paragraph"> </div>

 We show that decidable equality of the elements type implied decidable equality of vectors. 
</div>
<div class="code">

<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Instance</span> <span class="id" title="var">vector_eqdec</span> {<span class="id" title="var">A</span> <span class="id" title="var">n</span>} `(<span class="id" title="var">EqDec</span> <span class="id" title="var">A</span>) : <span class="id" title="var">EqDec</span> (<span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">left</span>. <span class="id" title="var">now</span> <span class="id" title="var">depelim</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">y</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">eq_dec</span> <span class="id" title="var">h</span> <span class="id" title="var">h0</span>); <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">IHx</span> <span class="id" title="var">y</span>). <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">left</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">n0</span>. <span class="id" title="var">noconf</span> <span class="id" title="var">H0</span>. <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">intro</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">n0</span>. <span class="id" title="var">noconf</span> <span class="id" title="var">H0</span>. <span class="id" title="tactic">constructor</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="keyword">Assumptions</span> <span class="id" title="var">vector_eqdec</span>.<br/>

<br/>
</div>

<div class="doc">
We automatically derive the signature and subterm relation for
    vectors and prove it's well-foundedness. The signature provides
    a <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Signature.html#signature_pack"><span class="id" title="definition">signature_pack</span></a></span> function to pack a vector with its index. The
    well-founded relation is defined on the packed vector type. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Derive</span> <span class="id" title="var">Subterm</span> <span class="id" title="keyword">for</span> <span class="id" title="var">vector</span>.<br/>

<br/>
</div>

<div class="doc">
The relation is actually called <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#t_subterm"><span class="id" title="definition">t_subterm</span></a></span> as <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#vector"><span class="id" title="abbreviation">vector</span></a></span> is just
    a notation for <span class="inlinecode"><span class="id" title="var">Vector.t</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">foo</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>}.<br/>

<br/>
</div>

<div class="doc">
We can use the packed relation to do well-founded recursion on the vector.
      Note that we do a recursive call on a substerm of type <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#vector"><span class="id" title="abbreviation">vector</span></a></span> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#well_founded_recursion_and_auxiliary_function.A"><span class="id" title="variable">A</span></a></span> <span class="inlinecode"><span class="id" title="var">n</span></span> which
      must be shown smaller than a <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#vector"><span class="id" title="abbreviation">vector</span></a></span> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#well_founded_recursion_and_auxiliary_function.A"><span class="id" title="variable">A</span></a></span> <span class="inlinecode">(<a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#Image.S"><span class="id" title="variable">S</span></a></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>. They are actually compared
      at the packed type <span class="inlinecode">{</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="http://rocq-prover.org/doc/V9.2+alpha/stdlib//Corelib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span> <span class="inlinecode">&amp;</span> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#vector"><span class="id" title="abbreviation">vector</span></a></span> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#well_founded_recursion_and_auxiliary_function.A"><span class="id" title="variable">A</span></a></span> <span class="inlinecode"><span class="id" title="var">n</span>}</span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Equations</span> <span class="id" title="var">unzip</span> {<span class="id" title="var">n</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> (<span class="id" title="var">A</span> × <span class="id" title="var">B</span>) <span class="id" title="var">n</span>) : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span> × <span class="id" title="var">vector</span> <span class="id" title="var">B</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">by</span> <span class="id" title="keyword">wf</span> (<span class="id" title="var">signature_pack</span> <span class="id" title="var">v</span>) (@<span class="id" title="var">t_subterm</span> (<span class="id" title="var">A</span> × <span class="id" title="var">B</span>)) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">unzip</span> []<span class="id" title="var">v</span> := ([]<span class="id" title="var">v</span>, []<span class="id" title="var">v</span>) ;<br/>
&nbsp;&nbsp;<span class="id" title="var">unzip</span> (<span class="id" title="var">Vector.cons</span> (<span class="id" title="var">x</span>, <span class="id" title="var">y</span>) <span class="id" title="var">v</span>) <span class="id" title="keyword">with</span> <span class="id" title="var">unzip</span> <span class="id" title="var">v</span> := {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">pair</span> <span class="id" title="var">xs</span> <span class="id" title="var">ys</span> := (<span class="id" title="var">Vector.cons</span> <span class="id" title="var">x</span> <span class="id" title="var">xs</span>, <span class="id" title="var">Vector.cons</span> <span class="id" title="var">y</span> <span class="id" title="var">ys</span>) }.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">foo</span>.<br/>

<br/>
</div>

<div class="doc">
Playing with lists and functional induction, we define a tail-recursive version
    of <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#rev"><span class="id" title="definition">rev</span></a></span> and show its equivalence with the "naïve" <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#rev"><span class="id" title="definition">rev</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">app</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">l</span> <span class="id" title="var">l'</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="var">app</span> <span class="id" title="var">nil</span> <span class="id" title="var">l</span> := <span class="id" title="var">l</span>;<br/>
<span class="id" title="var">app</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v</span>) <span class="id" title="var">l</span> := <span class="id" title="var">cons</span> <span class="id" title="var">a</span> (<span class="id" title="var">app</span> <span class="id" title="var">v</span> <span class="id" title="var">l</span>).<br/>

<br/>
#[<span class="id" title="var">warnings</span>="-notation-overridden"]<br/>
<span class="id" title="keyword">Infix</span> "++" := <span class="id" title="var">app</span> (<span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60) : <span class="id" title="var">list_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">rev_acc</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) (<span class="id" title="var">acc</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="var">rev_acc</span> <span class="id" title="var">nil</span> <span class="id" title="var">acc</span> := <span class="id" title="var">acc</span>;<br/>
<span class="id" title="var">rev_acc</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v</span>) <span class="id" title="var">acc</span> := <span class="id" title="var">rev_acc</span> <span class="id" title="var">v</span> (<span class="id" title="var">a</span> :: <span class="id" title="var">acc</span>).<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">rev</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="var">rev</span> <span class="id" title="var">nil</span> := <span class="id" title="var">nil</span>;<br/>
<span class="id" title="var">rev</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v</span>) := <span class="id" title="var">rev</span> <span class="id" title="var">v</span> ++ (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">nil</span>).<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot; [] " := <span class="id" title="var">List.nil</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">app_nil</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">l</span> ++ [] = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">funelim</span> (<span class="id" title="var">app</span> <span class="id" title="var">l</span> []); <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">app_assoc</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">l</span> <span class="id" title="var">l'</span> <span class="id" title="var">l''</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), (<span class="id" title="var">l</span> ++ <span class="id" title="var">l'</span>) ++ <span class="id" title="var">l''</span> = <span class="id" title="var">l</span> ++ (<span class="id" title="var">l'</span> ++ <span class="id" title="var">l''</span>).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="var">revert</span> <span class="id" title="var">l''</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">funelim</span> (<span class="id" title="var">l</span> ++ <span class="id" title="var">l'</span>); <span class="id" title="tactic">intros</span>; <span class="id" title="var">simp</span> <span class="id" title="var">app</span>; <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">rev_rev_acc</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">rev_acc</span> <span class="id" title="var">l</span> [] = <span class="id" title="var">rev</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">replace</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l</span>) <span class="id" title="keyword">with</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l</span> ++ []) <span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span> <span class="id" title="var">app_nil</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (@<span class="id" title="var">nil</span> <span class="id" title="var">A</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">funelim</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l</span>). <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l'</span>. <span class="id" title="var">simp</span> <span class="id" title="var">rev_acc</span>; <span class="id" title="tactic">trivial</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">app_assoc</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Rewrite</span> @<span class="id" title="var">rev_rev_acc</span> : <span class="id" title="var">rev_acc</span>.<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Rewrite</span> @<span class="id" title="var">app_nil</span> @<span class="id" title="var">app_assoc</span> : <span class="id" title="var">app</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">rev_app</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">l</span> <span class="id" title="var">l'</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">rev</span> (<span class="id" title="var">l</span> ++ <span class="id" title="var">l'</span>) = <span class="id" title="var">rev</span> <span class="id" title="var">l'</span> ++ <span class="id" title="var">rev</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="var">funelim</span> (<span class="id" title="var">l</span> ++ <span class="id" title="var">l'</span>); <span class="id" title="var">simp</span> <span class="id" title="var">rev</span> <span class="id" title="var">app</span>; <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> (<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>, &lt;- <span class="id" title="var">app_assoc</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">zip'</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> → <span class="id" title="var">A</span> → <span class="id" title="var">A</span>) (<span class="id" title="var">l</span> <span class="id" title="var">l'</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="var">zip'</span> <span class="id" title="var">f</span> <span class="id" title="var">nil</span> <span class="id" title="var">nil</span> := <span class="id" title="var">nil</span> ;<br/>
<span class="id" title="var">zip'</span> <span class="id" title="var">f</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v</span>) (<span class="id" title="var">cons</span> <span class="id" title="var">b</span> <span class="id" title="var">w</span>) := <span class="id" title="var">cons</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>) (<span class="id" title="var">zip'</span> <span class="id" title="var">f</span> <span class="id" title="var">v</span> <span class="id" title="var">w</span>) ;<br/>
<span class="id" title="var">zip'</span> <span class="id" title="var">f</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> := <span class="id" title="var">nil</span>.<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">zip''</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> → <span class="id" title="var">A</span> → <span class="id" title="var">A</span>) (<span class="id" title="var">l</span> <span class="id" title="var">l'</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) (<span class="id" title="var">def</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
<span class="id" title="var">zip''</span> <span class="id" title="var">f</span> <span class="id" title="var">nil</span> <span class="id" title="var">nil</span> <span class="id" title="var">def</span> := <span class="id" title="var">nil</span> ;<br/>
<span class="id" title="var">zip''</span> <span class="id" title="var">f</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v</span>) (<span class="id" title="var">cons</span> <span class="id" title="var">b</span> <span class="id" title="var">w</span>) <span class="id" title="var">def</span> := <span class="id" title="var">cons</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>) (<span class="id" title="var">zip''</span> <span class="id" title="var">f</span> <span class="id" title="var">v</span> <span class="id" title="var">w</span> <span class="id" title="var">def</span>) ;<br/>
<span class="id" title="var">zip''</span> <span class="id" title="var">f</span> <span class="id" title="var">nil</span> (<span class="id" title="var">cons</span> <span class="id" title="var">b</span> <span class="id" title="var">w</span>) <span class="id" title="var">def</span> := <span class="id" title="var">def</span> ;<br/>
<span class="id" title="var">zip''</span> <span class="id" title="var">f</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v</span>) <span class="id" title="var">nil</span> <span class="id" title="var">def</span> := <span class="id" title="var">def</span>.<br/>

<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">Vector</span>.<br/>

<br/>
</div>

<div class="doc">
Vectors 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">vector_append_one</span> {<span class="id" title="var">A</span> <span class="id" title="var">n</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) :=<br/>
<span class="id" title="var">vector_append_one</span> <span class="id" title="var">nil</span> <span class="id" title="var">a</span> := <span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">nil</span>;<br/>
<span class="id" title="var">vector_append_one</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a'</span> <span class="id" title="var">v</span>) <span class="id" title="var">a</span> := <span class="id" title="var">cons</span> <span class="id" title="var">a'</span> (<span class="id" title="var">vector_append_one</span> <span class="id" title="var">v</span> <span class="id" title="var">a</span>).<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">vrev</span> {<span class="id" title="var">A</span> <span class="id" title="var">n</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>) : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span> :=<br/>
<span class="id" title="var">vrev</span> <span class="id" title="var">nil</span> := <span class="id" title="var">nil</span>;<br/>
<span class="id" title="var">vrev</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v</span>) := <span class="id" title="var">vector_append_one</span> (<span class="id" title="var">vrev</span> <span class="id" title="var">v</span>) <span class="id" title="var">a</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">cast_vector</span> {<span class="id" title="var">A</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">n</span> = <span class="id" title="var">m</span>) : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">assumption</span>. <span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">vrev_acc</span> {<span class="id" title="var">A</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>) (<span class="id" title="var">w</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">m</span>) : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) :=<br/>
<span class="id" title="var">vrev_acc</span> <span class="id" title="var">nil</span> <span class="id" title="var">w</span> := <span class="id" title="var">w</span>;<br/>
<span class="id" title="var">vrev_acc</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v</span>) <span class="id" title="var">w</span> := <span class="id" title="var">cast_vector</span> (<span class="id" title="var">vrev_acc</span> <span class="id" title="var">v</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">w</span>)) <span class="id" title="var">_</span>.<br/>
<span class="comment">(*&nbsp;About&nbsp;vapp'.&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Record</span> <span class="id" title="var">vect</span> {<span class="id" title="var">A</span>} := <span class="id" title="var">mkVect</span> { <span class="id" title="var">vect_len</span> : <span class="id" title="var">nat</span>; <span class="id" title="var">vect_vector</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">vect_len</span> }.<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">mkVect</span> : <span class="id" title="var">vector</span> &gt;-&gt; <span class="id" title="var">vect</span>.<br/>
<span class="id" title="keyword">Derive</span> <span class="id" title="var">NoConfusion</span> <span class="id" title="keyword">for</span> <span class="id" title="var">vect</span>.<br/>

<br/>
</div>

<div class="doc">
Splitting a vector into two parts. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Split</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>}{<span class="id" title="var">m</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} : <span class="id" title="var">vector</span> <span class="id" title="var">X</span> (<span class="id" title="var">m</span> + <span class="id" title="var">n</span>) → <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">append</span> : ∀ (<span class="id" title="var">xs</span> : <span class="id" title="var">vector</span> <span class="id" title="var">X</span> <span class="id" title="var">m</span>)(<span class="id" title="var">ys</span> : <span class="id" title="var">vector</span> <span class="id" title="var">X</span> <span class="id" title="var">n</span>), <span class="id" title="var">Split</span> (<span class="id" title="var">vapp</span> <span class="id" title="var">xs</span> <span class="id" title="var">ys</span>).<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">Split</span> [ <span class="id" title="var">X</span> ].<br/>

<br/>
</div>

<div class="doc">
We split by well-founded recursion on the index <span class="inlinecode"><span class="id" title="var">m</span></span> here. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="tactic">split</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">m</span> <span class="id" title="var">n</span>} (<span class="id" title="var">xs</span> : <span class="id" title="var">vector</span> <span class="id" title="var">X</span> (<span class="id" title="var">m</span> + <span class="id" title="var">n</span>)) : <span class="id" title="var">Split</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">xs</span> <span class="id" title="tactic">by</span> <span class="id" title="keyword">wf</span> <span class="id" title="var">m</span> :=<br/>
<span class="id" title="tactic">split</span> (<span class="id" title="var">m</span>:=<span class="id" title="var">O</span>) <span class="id" title="var">xs</span> := <span class="id" title="var">append</span> <span class="id" title="var">nil</span> <span class="id" title="var">xs</span> ;<br/>
<span class="id" title="tactic">split</span> (<span class="id" title="var">m</span>:=<span class="id" title="var">S</span> <span class="id" title="var">m</span>) (<span class="id" title="var">cons</span> <span class="id" title="var">x</span> <span class="id" title="var">xs</span>) <span class="id" title="keyword">with</span> <span class="id" title="tactic">split</span> <span class="id" title="var">xs</span> ⇒ {<br/>
&nbsp;&nbsp;| <span class="id" title="var">append</span> <span class="id" title="var">xs'</span> <span class="id" title="var">ys'</span> := <span class="id" title="var">append</span> (<span class="id" title="var">cons</span> <span class="id" title="var">x</span> <span class="id" title="var">xs'</span>) <span class="id" title="var">ys'</span> }.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" title="tactic">split</span></span> and <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#vapp"><span class="id" title="definition">vapp</span></a></span> functions are inverses. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">split_vapp</span> : ∀ (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) <span class="id" title="var">m</span> <span class="id" title="var">n</span> (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">X</span> <span class="id" title="var">m</span>) (<span class="id" title="var">w</span> : <span class="id" title="var">vector</span> <span class="id" title="var">X</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> '<span class="id" title="var">append</span> <span class="id" title="var">v'</span> <span class="id" title="var">w'</span> := <span class="id" title="tactic">split</span> (<span class="id" title="var">vapp</span> <span class="id" title="var">v</span> <span class="id" title="var">w</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">v</span> = <span class="id" title="var">v'</span> ∧ <span class="id" title="var">w</span> = <span class="id" title="var">w'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">funelim</span> (<span class="id" title="var">vapp</span> <span class="id" title="var">v</span> <span class="id" title="var">w</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="tactic">split</span>. <span class="id" title="var">depelim</span> <span class="id" title="var">xs</span>; <span class="id" title="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">simp</span> <span class="id" title="tactic">split</span> <span class="id" title="tactic">in</span> ×. <span class="id" title="tactic">destruct</span> <span class="id" title="tactic">split</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intuition</span> <span class="id" title="tactic">congruence</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="comment">(*&nbsp;Eval&nbsp;compute&nbsp;in&nbsp;@zip''.&nbsp;*)</span><br/>

<br/>
#[<span class="id" title="var">warnings</span>="-deprecated-library-file-since-8.20"]<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Stdlib</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Bvector</span>.<br/>

<br/>
</div>

<div class="doc">
This function can also be defined by structural recursion on <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">split_struct</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">m</span> <span class="id" title="var">n</span>} (<span class="id" title="var">xs</span> : <span class="id" title="var">vector</span> <span class="id" title="var">X</span> (<span class="id" title="var">m</span> + <span class="id" title="var">n</span>)) : <span class="id" title="var">Split</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">xs</span> :=<br/>
<span class="id" title="var">split_struct</span> (<span class="id" title="var">m</span>:=0) <span class="id" title="var">xs</span> := <span class="id" title="var">append</span> <span class="id" title="var">nil</span> <span class="id" title="var">xs</span> ;<br/>
<span class="id" title="var">split_struct</span> (<span class="id" title="var">m</span>:=(<span class="id" title="var">S</span> <span class="id" title="var">m</span>)) (<span class="id" title="var">cons</span> <span class="id" title="var">x</span> <span class="id" title="var">xs</span>) <span class="id" title="keyword">with</span> <span class="id" title="var">split_struct</span> <span class="id" title="var">xs</span> ⇒ {<br/>
&nbsp;&nbsp;<span class="id" title="var">split_struct</span> (<span class="id" title="var">m</span>:=(<span class="id" title="var">S</span> <span class="id" title="var">m</span>)) (<span class="id" title="var">cons</span> <span class="id" title="var">x</span> <span class="id" title="var">xs</span>) (<span class="id" title="var">append</span> <span class="id" title="var">xs'</span> <span class="id" title="var">ys'</span>) := <span class="id" title="var">append</span> (<span class="id" title="var">cons</span> <span class="id" title="var">x</span> <span class="id" title="var">xs'</span>) <span class="id" title="var">ys'</span> }.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">split_struct_vapp</span> : ∀ (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) <span class="id" title="var">m</span> <span class="id" title="var">n</span> (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">X</span> <span class="id" title="var">m</span>) (<span class="id" title="var">w</span> : <span class="id" title="var">vector</span> <span class="id" title="var">X</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> '<span class="id" title="var">append</span> <span class="id" title="var">v'</span> <span class="id" title="var">w'</span> := <span class="id" title="var">split_struct</span> (<span class="id" title="var">vapp</span> <span class="id" title="var">v</span> <span class="id" title="var">w</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">v</span> = <span class="id" title="var">v'</span> ∧ <span class="id" title="var">w</span> = <span class="id" title="var">w'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">funelim</span> (<span class="id" title="var">vapp</span> <span class="id" title="var">v</span> <span class="id" title="var">w</span>); <span class="id" title="var">simp</span> <span class="id" title="var">split_struct</span> <span class="id" title="tactic">in</span> ×.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">split_struct</span>. <span class="id" title="var">depelim</span> <span class="id" title="var">xs</span>; <span class="id" title="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">split_struct</span> (<span class="id" title="var">vapp</span> <span class="id" title="var">v</span> <span class="id" title="var">_</span>)); <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intuition</span> <span class="id" title="tactic">congruence</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taking the head of a non-empty vector. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">vhead</span> {<span class="id" title="var">A</span> <span class="id" title="var">n</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) : <span class="id" title="var">A</span> := <br/>
<span class="id" title="var">vhead</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v</span>) := <span class="id" title="var">a</span>.<br/>

<br/>
</div>

<div class="doc">
Mapping over a vector. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">vmap'</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span>) {<span class="id" title="var">n</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>) : <span class="id" title="var">vector</span> <span class="id" title="var">B</span> <span class="id" title="var">n</span> :=<br/>
<span class="id" title="var">vmap'</span> <span class="id" title="var">f</span> <span class="id" title="var">nil</span> := <span class="id" title="var">nil</span> ;<br/>
<span class="id" title="var">vmap'</span> <span class="id" title="var">f</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v</span>) := <span class="id" title="var">cons</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>) (<span class="id" title="var">vmap'</span> <span class="id" title="var">f</span> <span class="id" title="var">v</span>).<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Resolve</span> <span class="id" title="var">Nat.lt_succ_diag_r</span> : <span class="id" title="var">subterm_relation</span>.<br/>
<span class="id" title="keyword">Transparent</span> <span class="id" title="var">vmap'</span>.<br/>

<br/>
</div>

<div class="doc">
The same, using well-founded recursion on <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Equations</span> <span class="id" title="var">vmap</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span>) {<span class="id" title="var">n</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>) : <span class="id" title="var">vector</span> <span class="id" title="var">B</span> <span class="id" title="var">n</span> <span class="id" title="tactic">by</span> <span class="id" title="keyword">wf</span> <span class="id" title="var">n</span> :=<br/>
<span class="id" title="var">vmap</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span>:=?(<span class="id" title="var">O</span>)) <span class="id" title="var">nil</span> := <span class="id" title="var">nil</span> ;<br/>
<span class="id" title="var">vmap</span> <span class="id" title="var">f</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v</span>) := <span class="id" title="var">cons</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>) (<span class="id" title="var">vmap</span> <span class="id" title="var">f</span> <span class="id" title="var">v</span>).<br/>

<br/>
<span class="id" title="keyword">Transparent</span> <span class="id" title="var">vmap</span>.<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="tactic">in</span> (<span class="id" title="var">vmap'</span> <span class="id" title="var">id</span> (@<span class="id" title="var">nil</span> <span class="id" title="var">nat</span>)).<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="tactic">in</span> (<span class="id" title="var">vmap'</span> <span class="id" title="var">id</span> (@<span class="id" title="var">cons</span> <span class="id" title="var">nat</span> 2 <span class="id" title="var">_</span> <span class="id" title="var">nil</span>)).<br/>

<br/>
</div>

<div class="doc">
The image of a function. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">Image</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> {<span class="id" title="var">S</span> <span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>}.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">f</span> : <span class="id" title="var">S</span> → <span class="id" title="var">T</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Imf</span> : <span class="id" title="var">T</span> → <span class="id" title="keyword">Type</span> := <span class="id" title="var">imf</span> (<span class="id" title="var">s</span> : <span class="id" title="var">S</span>) : <span class="id" title="var">Imf</span> (<span class="id" title="var">f</span> <span class="id" title="var">s</span>).<br/>

<br/>
</div>

<div class="doc">
Here <span class="inlinecode">(<a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#well_founded_recursion_and_auxiliary_function.f"><span class="id" title="variable">f</span></a></span> <span class="inlinecode"><span class="id" title="var">s</span>)</span> is innaccessible. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Equations</span> <span class="id" title="var">inv</span> (<span class="id" title="var">t</span> : <span class="id" title="var">T</span>) (<span class="id" title="var">im</span> : <span class="id" title="var">Imf</span> <span class="id" title="var">t</span>) : <span class="id" title="var">S</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">inv</span> ?(<span class="id" title="var">f</span> <span class="id" title="var">s</span>) (<span class="id" title="var">imf</span> <span class="id" title="var">s</span>) := <span class="id" title="var">s</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Image</span>.<br/>

<br/>
</div>

<div class="doc">
Working with a universe of types with an interpretation function. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">Univ</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <span class="id" title="var">univ</span> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">ubool</span> | <span class="id" title="var">unat</span> | <span class="id" title="var">uarrow</span> (<span class="id" title="var">from</span>:<span class="id" title="var">univ</span>) (<span class="id" title="var">to</span>:<span class="id" title="var">univ</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Equations</span> <span class="id" title="var">interp</span> (<span class="id" title="var">u</span> : <span class="id" title="var">univ</span>) : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">interp</span> <span class="id" title="var">ubool</span> := <span class="id" title="var">bool</span>; <span class="id" title="var">interp</span> <span class="id" title="var">unat</span> := <span class="id" title="var">nat</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">interp</span> (<span class="id" title="var">uarrow</span> <span class="id" title="var">from</span> <span class="id" title="var">to</span>) := <span class="id" title="var">interp</span> <span class="id" title="var">from</span> → <span class="id" title="var">interp</span> <span class="id" title="var">to</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Transparent</span> <span class="id" title="var">interp</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">interp'</span> := <span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="tactic">in</span> @<span class="id" title="var">interp</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Equations</span> <span class="id" title="var">foo</span> (<span class="id" title="var">u</span> : <span class="id" title="var">univ</span>) (<span class="id" title="var">el</span> : <span class="id" title="var">interp'</span> <span class="id" title="var">u</span>) : <span class="id" title="var">interp'</span> <span class="id" title="var">u</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">foo</span> <span class="id" title="var">ubool</span> <span class="id" title="var">true</span> := <span class="id" title="var">false</span> ;<br/>
&nbsp;&nbsp;<span class="id" title="var">foo</span> <span class="id" title="var">ubool</span> <span class="id" title="var">false</span> := <span class="id" title="var">true</span> ;<br/>
&nbsp;&nbsp;<span class="id" title="var">foo</span> <span class="id" title="var">unat</span> <span class="id" title="var">t</span> := <span class="id" title="var">t</span> ;<br/>
&nbsp;&nbsp;<span class="id" title="var">foo</span> (<span class="id" title="var">uarrow</span> <span class="id" title="var">from</span> <span class="id" title="var">to</span>) <span class="id" title="var">f</span> := <span class="id" title="var">id</span> ∘ <span class="id" title="var">f</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Transparent</span> <span class="id" title="var">foo</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Eval&nbsp;lazy&nbsp;beta&nbsp;delta&nbsp;<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">foo</span></span> <span class="inlinecode"><span class="id" title="var">foo_obligation_1</span></span> <span class="inlinecode"><span class="id" title="var">foo_obligation_2</span></span> <span class="inlinecode"></span>&nbsp;iota&nbsp;zeta&nbsp;in&nbsp;foo.&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Univ</span>.<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">vlast</span> {<span class="id" title="var">A</span>} {<span class="id" title="var">n</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) : <span class="id" title="var">A</span> <span class="id" title="tactic">by</span> <span class="id" title="keyword">struct</span> <span class="id" title="var">v</span> :=<br/>
<span class="id" title="var">vlast</span> (@<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">O</span> <span class="id" title="var">_</span>) := <span class="id" title="var">a</span> ;<br/>
<span class="id" title="var">vlast</span> (@<span class="id" title="var">cons</span> <span class="id" title="var">a</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="var">v</span>) := <span class="id" title="var">vlast</span> <span class="id" title="var">v</span>.<br/>
<span class="id" title="keyword">Transparent</span> <span class="id" title="var">vlast</span>.<br/>

<br/>
</div>

<div class="doc">
The parity predicate embeds a divisor of n or n-1 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Parity</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">even</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">Parity</span> (<span class="id" title="var">mult</span> 2 <span class="id" title="var">n</span>)<br/>
| <span class="id" title="var">odd</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">Parity</span> (<span class="id" title="var">S</span> (<span class="id" title="var">mult</span> 2 <span class="id" title="var">n</span>)).<br/>

<br/>
<span class="comment">(*&nbsp;Eval&nbsp;compute&nbsp;in&nbsp;(fun&nbsp;n&nbsp;=&gt;&nbsp;mult&nbsp;2&nbsp;(S&nbsp;n)).&nbsp;*)</span><br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">cast</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">A</span> = <span class="id" title="var">B</span>) : <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">a</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">parity</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">Parity</span> <span class="id" title="var">n</span> :=<br/>
<span class="id" title="var">parity</span> <span class="id" title="var">O</span> := <span class="id" title="var">even</span> 0 ;<br/>
<span class="id" title="var">parity</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="keyword">with</span> <span class="id" title="var">parity</span> <span class="id" title="var">n</span> ⇒ {<br/>
&nbsp;&nbsp;<span class="id" title="var">parity</span> (<span class="id" title="var">S</span> ?(<span class="id" title="var">mult</span> 2 <span class="id" title="var">k</span>))     (<span class="id" title="var">even</span> <span class="id" title="var">k</span>) := <span class="id" title="var">odd</span> <span class="id" title="var">k</span> ;<br/>
&nbsp;&nbsp;<span class="id" title="var">parity</span> (<span class="id" title="var">S</span> ?(<span class="id" title="var">S</span> (<span class="id" title="var">mult</span> 2 <span class="id" title="var">k</span>))) (<span class="id" title="var">odd</span> <span class="id" title="var">k</span>)  := <span class="id" title="var">cast</span> (<span class="id" title="var">even</span> (<span class="id" title="var">S</span> <span class="id" title="var">k</span>)) <span class="id" title="var">_</span> }.<br/>

<br/>
</div>

<div class="doc">
We can halve a natural looking at its parity and using the lower truncation. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">half</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="var">half</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span> <span class="id" title="var">parity</span> <span class="id" title="var">n</span> ⇒ {<br/>
&nbsp;&nbsp;<span class="id" title="var">half</span> ?(<span class="id" title="var">S</span> (<span class="id" title="var">mult</span> 2 <span class="id" title="var">k</span>)) (<span class="id" title="var">odd</span> <span class="id" title="var">k</span>) := <span class="id" title="var">k</span> ;<br/>
&nbsp;&nbsp;<span class="id" title="var">half</span> ?(<span class="id" title="var">mult</span> 2 <span class="id" title="var">k</span>) (<span class="id" title="var">even</span> <span class="id" title="var">k</span>) := <span class="id" title="var">k</span> }.<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">vtail</span> {<span class="id" title="var">A</span> <span class="id" title="var">n</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">vtail</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v'</span>) := <span class="id" title="var">v'</span>.<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">diag</span> {<span class="id" title="var">A</span> <span class="id" title="var">n</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> (<span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>) <span class="id" title="var">n</span>) : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span> :=<br/>
<span class="id" title="var">diag</span> (<span class="id" title="var">n</span>:=<span class="id" title="var">O</span>) <span class="id" title="var">nil</span> := <span class="id" title="var">nil</span> ;<br/>
<span class="id" title="var">diag</span> (<span class="id" title="var">n</span>:=<span class="id" title="var">S</span> ?(<span class="id" title="var">n</span>)) (<span class="id" title="var">cons</span> (@<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">n</span> <span class="id" title="var">v</span>) <span class="id" title="var">v'</span>) := <span class="id" title="var">cons</span> <span class="id" title="var">a</span> (<span class="id" title="var">diag</span> (<span class="id" title="var">vmap</span> <span class="id" title="var">vtail</span> <span class="id" title="var">v'</span>)).<br/>
<span class="id" title="keyword">Transparent</span> <span class="id" title="var">diag</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mat</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> := <span class="id" title="var">vector</span> (<span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">m</span>) <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">vmake</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span> :=<br/>
<span class="id" title="var">vmake</span> <span class="id" title="var">O</span> <span class="id" title="var">a</span> := <span class="id" title="var">nil</span> ;<br/>
<span class="id" title="var">vmake</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="var">a</span> := <span class="id" title="var">cons</span> <span class="id" title="var">a</span> (<span class="id" title="var">vmake</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span>).<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">vfold_right</span> {<span class="id" title="var">A</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Type</span>} {<span class="id" title="var">B</span>} (<span class="id" title="var">f</span> : ∀ <span class="id" title="var">n</span>, <span class="id" title="var">B</span> → <span class="id" title="var">A</span> <span class="id" title="var">n</span> → <span class="id" title="var">A</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) (<span class="id" title="var">e</span> : <span class="id" title="var">A</span> 0) {<span class="id" title="var">n</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">B</span> <span class="id" title="var">n</span>) : <span class="id" title="var">A</span> <span class="id" title="var">n</span> :=<br/>
<span class="id" title="var">vfold_right</span> <span class="id" title="var">f</span> <span class="id" title="var">e</span> <span class="id" title="var">nil</span> := <span class="id" title="var">e</span> ;<br/>
<span class="id" title="var">vfold_right</span> <span class="id" title="var">f</span> <span class="id" title="var">e</span> (@<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">n</span> <span class="id" title="var">v</span>) := <span class="id" title="var">f</span> <span class="id" title="var">n</span> <span class="id" title="var">a</span> (<span class="id" title="var">vfold_right</span> <span class="id" title="var">f</span> <span class="id" title="var">e</span> <span class="id" title="var">v</span>).<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">vzip</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">n</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span> → <span class="id" title="var">C</span>) (<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>) (<span class="id" title="var">w</span> : <span class="id" title="var">vector</span> <span class="id" title="var">B</span> <span class="id" title="var">n</span>) : <span class="id" title="var">vector</span> <span class="id" title="var">C</span> <span class="id" title="var">n</span> :=<br/>
<span class="id" title="var">vzip</span> <span class="id" title="var">f</span> <span class="id" title="var">nil</span> <span class="id" title="var">_</span> := <span class="id" title="var">nil</span> ;<br/>
<span class="id" title="var">vzip</span> <span class="id" title="var">f</span> (<span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">v</span>) (<span class="id" title="var">cons</span> <span class="id" title="var">a'</span> <span class="id" title="var">v'</span>) := <span class="id" title="var">cons</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span>) (<span class="id" title="var">vzip</span> <span class="id" title="var">f</span> <span class="id" title="var">v</span> <span class="id" title="var">v'</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">transpose</span> {<span class="id" title="var">A</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>} : <span class="id" title="var">mat</span> <span class="id" title="var">A</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> → <span class="id" title="var">mat</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">vfold_right</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">λ</span> <span class="id" title="var">m</span>, <span class="id" title="var">mat</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">λ</span> <span class="id" title="var">m'</span>, <span class="id" title="var">vzip</span> (<span class="id" title="var">λ</span> <span class="id" title="var">a</span>, <span class="id" title="var">cons</span> <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">vmake</span> <span class="id" title="var">n</span> <span class="id" title="var">nil</span>).<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Examples.Fin</span>.<br/>

<br/>
<span class="id" title="keyword">Generalizable All Variables</span>.<br/>

<br/>
<span class="id" title="keyword">Opaque</span> <span class="id" title="var">vmap</span>. <span class="id" title="keyword">Opaque</span> <span class="id" title="var">vtail</span>. <span class="id" title="keyword">Opaque</span> <span class="id" title="var">nth</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nth_vmap</span> `(<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>) `(<span class="id" title="var">fn</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">fin</span> <span class="id" title="var">n</span>) : <span class="id" title="var">nth</span> (<span class="id" title="var">vmap</span> <span class="id" title="var">fn</span> <span class="id" title="var">v</span>) <span class="id" title="var">f</span> = <span class="id" title="var">fn</span> (<span class="id" title="var">nth</span> <span class="id" title="var">v</span> <span class="id" title="var">f</span>).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">revert</span> <span class="id" title="var">B</span> <span class="id" title="var">fn</span>. <span class="id" title="var">funelim</span> (<span class="id" title="var">nth</span> <span class="id" title="var">v</span> <span class="id" title="var">f</span>); <span class="id" title="tactic">intros</span>; <span class="id" title="var">now</span> <span class="id" title="var">simp</span> <span class="id" title="var">nth</span> <span class="id" title="var">vmap</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nth_vtail</span> `(<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> <span class="id" title="var">A</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) (<span class="id" title="var">f</span> : <span class="id" title="var">fin</span> <span class="id" title="var">n</span>) : <span class="id" title="var">nth</span> (<span class="id" title="var">vtail</span> <span class="id" title="var">v</span>) <span class="id" title="var">f</span> = <span class="id" title="var">nth</span> <span class="id" title="var">v</span> (<span class="id" title="var">fs</span> <span class="id" title="var">f</span>).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">funelim</span> (<span class="id" title="var">vtail</span> <span class="id" title="var">v</span>); <span class="id" title="tactic">intros</span>; <span class="id" title="var">now</span> <span class="id" title="var">simp</span> <span class="id" title="var">nth</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Rewrite</span> @<span class="id" title="var">nth_vmap</span> @<span class="id" title="var">nth_vtail</span> : <span class="id" title="var">nth</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">diag_nth</span> `(<span class="id" title="var">v</span> : <span class="id" title="var">vector</span> (<span class="id" title="var">vector</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>) <span class="id" title="var">n</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">fin</span> <span class="id" title="var">n</span>) : <span class="id" title="var">nth</span> (<span class="id" title="var">diag</span> <span class="id" title="var">v</span>) <span class="id" title="var">f</span> = <span class="id" title="var">nth</span> (<span class="id" title="var">nth</span> <span class="id" title="var">v</span> <span class="id" title="var">f</span>) <span class="id" title="var">f</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">revert</span> <span class="id" title="var">f</span>. <span class="id" title="var">funelim</span> (<span class="id" title="var">diag</span> <span class="id" title="var">v</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">depelim</span> <span class="id" title="var">f</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="var">depelim</span> <span class="id" title="var">f</span>; <span class="id" title="var">simp</span> <span class="id" title="var">nth</span>; <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="var">now</span> <span class="id" title="var">simp</span> <span class="id" title="var">nth</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">assoc</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">x</span> + <span class="id" title="var">y</span> + <span class="id" title="var">z</span> = <span class="id" title="var">x</span> + (<span class="id" title="var">y</span> + <span class="id" title="var">z</span>) :=<br/>
<span class="id" title="var">assoc</span> 0 <span class="id" title="var">y</span> <span class="id" title="var">z</span> := <span class="id" title="var">eq_refl</span>;<br/>
<span class="id" title="var">assoc</span> (<span class="id" title="var">S</span> <span class="id" title="var">x</span>) <span class="id" title="var">y</span> <span class="id" title="var">z</span> <span class="id" title="keyword">with</span> <span class="id" title="var">assoc</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <span class="id" title="var">x</span> + (<span class="id" title="var">y</span> + <span class="id" title="var">z</span>) ⇒ {<br/>
<span class="id" title="var">assoc</span> (<span class="id" title="var">S</span> <span class="id" title="var">x</span>) <span class="id" title="var">y</span> <span class="id" title="var">z</span> <span class="id" title="var">eq_refl</span> <span class="id" title="var">_</span> := <span class="id" title="var">eq_refl</span> }.<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">well_founded_recursion_and_auxiliary_function</span>.<br/>

<br/>
</div>

<div class="doc">
When recursive calls are made on results pattern-matching
   the output of auxiliary functions, you need enough information
   to prove that the argument of recursive calls are smaller.
   This is usually granted by the specification of the auxiliary
   function (see function pivot in the quicksort example).
   When the type of the recursive function is not informative
   enough, we can use an inspect pattern as illustrated
   in the following example. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Context</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> → <span class="id" title="var">option</span> <span class="id" title="var">A</span>) {<span class="id" title="var">lt</span> : <span class="id" title="var">A</span> → <span class="id" title="var">A</span> → <span class="id" title="keyword">Prop</span>}<br/>
&nbsp;`{<span class="id" title="var">WellFounded</span> <span class="id" title="var">A</span> <span class="id" title="var">lt</span>}.<br/>

<br/>
<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">decr_f</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">p</span>, <span class="id" title="var">f</span> <span class="id" title="var">n</span> = <span class="id" title="var">Some</span> <span class="id" title="var">p</span> → <span class="id" title="var">lt</span> <span class="id" title="var">p</span> <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#inspect"><span class="id" title="definition">inspect</span></a></span> definition is used to pack a value with a proof
  of an equality to itself. When pattern matching on the first component in 
  this existential type, we keep information about the origin of the pattern 
  available in the second component, the equality.  
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">inspect</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) : {<span class="id" title="var">b</span> | <span class="id" title="var">a</span> = <span class="id" title="var">b</span>} :=<br/>
&nbsp;&nbsp;<span class="id" title="var">exist</span> <span class="id" title="var">_</span> <span class="id" title="var">a</span> <span class="id" title="var">eq_refl</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;x 'eqn:' p" := (<span class="id" title="var">exist</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">p</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 20).<br/>

<br/>
</div>

<div class="doc">
If one uses <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#well_founded_recursion_and_auxiliary_function.f"><span class="id" title="variable">f</span></a></span> <span class="inlinecode"><span class="id" title="var">n</span></span> instead of <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#inspect"><span class="id" title="definition">inspect</span></a></span> <span class="inlinecode">(<a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#well_founded_recursion_and_auxiliary_function.f"><span class="id" title="variable">f</span></a></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> in the following definition,
   patterns should be patterns for the option type, but then there
   is an unprovable obligation that is generated as we don't keep information
   about the call to <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#well_founded_recursion_and_auxiliary_function.f"><span class="id" title="variable">f</span></a></span> <span class="inlinecode"><span class="id" title="var">n</span></span> being equal to <span class="inlinecode"><a class="idref" href="http://rocq-prover.org/doc/V9.2+alpha/stdlib//Corelib.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a></span> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#FilterDef.p"><span class="id" title="variable">p</span></a></span> to justify the recursive
   call to <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.Basics.html#f_sequence"><span class="id" title="definition">f_sequence</span></a></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Equations</span> <span class="id" title="var">f_sequence</span> (<span class="id" title="var">n</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> <span class="id" title="tactic">by</span> <span class="id" title="keyword">wf</span> <span class="id" title="var">n</span> <span class="id" title="var">lt</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">f_sequence</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span> <span class="id" title="var">inspect</span> (<span class="id" title="var">f</span> <span class="id" title="var">n</span>) := {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some</span> <span class="id" title="var">p</span> <span class="id" title="var">eqn</span>: <span class="id" title="var">eq1</span> ⇒ <span class="id" title="var">p</span> :: <span class="id" title="var">f_sequence</span> <span class="id" title="var">p</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">_</span> ⇒ <span class="id" title="var">List.nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;}.<br/>

<br/>
</div>

<div class="doc">
The following is an illustration of a theorem on f_sequence. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">in_seq_image</span> (<span class="id" title="var">n</span> <span class="id" title="var">p</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">List.In</span> <span class="id" title="var">p</span> (<span class="id" title="var">f_sequence</span> <span class="id" title="var">n</span>) →<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">k</span>, <span class="id" title="var">f</span> <span class="id" title="var">k</span> = <span class="id" title="var">Some</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">funelim</span> (<span class="id" title="var">f_sequence</span> <span class="id" title="var">n</span>);[ | <span class="id" title="var">now</span> <span class="id" title="tactic">intros</span> <span class="id" title="var">abs</span>; <span class="id" title="tactic">elim</span> <span class="id" title="var">abs</span>].<br/>
<span class="id" title="var">now</span> <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">p_is_a</span> | <span class="id" title="var">p_in_seq</span>];[<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">p_is_a</span>; <span class="id" title="tactic">∃</span> <span class="id" title="var">n</span> | <span class="id" title="tactic">auto</span>].<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">well_founded_recursion_and_auxiliary_function</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">IdElim</span>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">Sigma_Notations</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="keyword">Equations</span> <span class="id" title="keyword">Transparent</span>.<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">transport</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> → <span class="id" title="keyword">Type</span>) {<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span>) (<span class="id" title="var">u</span> : <span class="id" title="var">P</span> <span class="id" title="var">x</span>) : <span class="id" title="var">P</span> <span class="id" title="var">y</span> :=<br/>
<span class="id" title="var">transport</span> <span class="id" title="var">P</span> <span class="id" title="var">eq_refl</span> <span class="id" title="var">u</span> := <span class="id" title="var">u</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;p # x" := (<span class="id" title="var">transport</span> <span class="id" title="var">_</span> <span class="id" title="var">p</span> <span class="id" title="var">x</span>) (<span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 65, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>).<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">path_sigma</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">P</span> : <span class="id" title="var">A</span> → <span class="id" title="keyword">Type</span>} (<span class="id" title="var">u</span> <span class="id" title="var">v</span> : <span class="id" title="var">sigma</span> <span class="id" title="var">P</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">p</span> : <span class="id" title="var">u</span>.1 = <span class="id" title="var">v</span>.1) (<span class="id" title="var">q</span> : <span class="id" title="var">p</span> # <span class="id" title="var">u</span>.2 = <span class="id" title="var">v</span>.2) : <span class="id" title="var">u</span> = <span class="id" title="var">v</span> := <br/>
<span class="id" title="var">path_sigma</span> (<span class="id" title="var">_</span> , <span class="id" title="var">_</span>) (<span class="id" title="var">_</span> , <span class="id" title="var">_</span>) <span class="id" title="var">eq_refl</span> <span class="id" title="var">eq_refl</span> := <span class="id" title="var">eq_refl</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">foo</span> := <span class="id" title="var">path_sigma_elim</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">IdElim</span>.<br/>
</div>
<hr/>This page has been generated by <a href="http://rocq-prover.org/">coqdoc</a>
</div>

</div>

</body>
</html>