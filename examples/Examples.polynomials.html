<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Examples.polynomials</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<div class="code">
</div>

<div class="doc">
<a id="lab1"></a><h1 class="section">Polynomials</h1>


<div class="paragraph"> </div>

  Polynomials and a reflexive tactic for solving boolean goals (using
  heyting or classical boolean algebra).  Original version by Rafael
  Bocquet, 2016. Updated to use Equations for all definitions by M. Sozeau,
  2016-2017. If running this interactively you can ignore the printing
  and hide directives which are just used to instruct coqdoc. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
We start with a simple definition deciding if some integer is equal
    to <span class="inlinecode">0</span> or not. Integers are encoded using an inductive type <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Numbers.BinNums.html#Z"><span class="id" title="inductive">Z</span></a></span>
    with three constructors <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Numbers.BinNums.html#Z0"><span class="id" title="constructor">Z0</span></a></span>, <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Numbers.BinNums.html#Zpos"><span class="id" title="constructor">Zpos</span></a></span> and <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Numbers.BinNums.html#Zneg"><span class="id" title="constructor">Zneg</span></a></span>, the latter two
    taking <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Numbers.BinNums.html#positive"><span class="id" title="inductive">positive</span></a></span> numbers as arguments. There is a single
    representant of <span class="inlinecode">0</span> which we discriminate here. The second clause
    actually captures both the <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Numbers.BinNums.html#Zpos"><span class="id" title="constructor">Zpos</span></a></span> and <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Numbers.BinNums.html#Zneg"><span class="id" title="constructor">Zneg</span></a></span> constructors.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">IsNZ</span> (<span class="id" title="var">z</span> : <span class="id" title="var">Z</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">IsNZ</span> <span class="id" title="var">Z0</span> := <span class="id" title="var">false</span>; <span class="id" title="var">IsNZ</span> <span class="id" title="var">_</span> := <span class="id" title="var">true</span>.<br/>

<br/>
</div>

<div class="doc">
The specification of this test is that it returns true iff the variable is indeed
    different from <span class="inlinecode">0</span> w.r.t. the standard Leibniz equality. We elide a simple proof
    by case analysis. Note that we use an implicit coercion from <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a></span> to <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> here,
    as is usual when doing boolean reflection. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">IsNZ_spec</span> <span class="id" title="var">z</span> : <span class="id" title="var">IsNZ</span> <span class="id" title="var">z</span> ↔ (<span class="id" title="var">z</span> ≠ 0)%<span class="id" title="var">Z</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">funelim</span> (<span class="id" title="var">IsNZ</span> <span class="id" title="var">z</span>); <span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">intros</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">discriminate</span> || <span class="id" title="var">contradiction</span> || <span class="id" title="tactic">constructor</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab2"></a><h3 class="section">Multivariate polynomials</h3>


<div class="paragraph"> </div>

   Using an indexed inductive type, we ensure that polynomials of
    have a unique
   representation.  The first index indicates that the polynom is
   null. The second index gives the number of free variables. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">poly</span> : <span class="id" title="var">bool</span> → <span class="id" title="var">nat</span> → <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">poly_z</span> : <span class="id" title="var">poly</span> <span class="id" title="var">true</span> <span class="id" title="var">O</span><br/>
| <span class="id" title="var">poly_c</span> (<span class="id" title="var">z</span> : <span class="id" title="var">Z</span>) : <span class="id" title="var">IsNZ</span> <span class="id" title="var">z</span> → <span class="id" title="var">poly</span> <span class="id" title="var">false</span> <span class="id" title="var">O</span><br/>
| <span class="id" title="var">poly_l</span> {<span class="id" title="var">n</span> <span class="id" title="var">b</span>} (<span class="id" title="var">Q</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span>) : <span class="id" title="var">poly</span> <span class="id" title="var">b</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)<br/>
| <span class="id" title="var">poly_s</span> {<span class="id" title="var">n</span> <span class="id" title="var">b</span>} (<span class="id" title="var">P</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span>) (<span class="id" title="var">Q</span> : <span class="id" title="var">poly</span> <span class="id" title="var">false</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">poly</span> <span class="id" title="var">false</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
<ul class="doclist">
<li> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_z"><span class="id" title="constructor">poly_z</span></a></span> represents the null polynomial.

</li>
<li> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_c"><span class="id" title="constructor">poly_c</span></a></span> <span class="inlinecode"><span class="id" title="var">c</span></span> represents the constant polynomial <span class="inlinecode"><span class="id" title="var">c</span></span> where <span class="inlinecode"><span class="id" title="var">c</span></span> is non-zero (i.e. has a proof of <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#IsNZ"><span class="id" title="definition">IsNZ</span></a></span> <span class="inlinecode"><span class="id" title="var">c</span></span>).

</li>
<li> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_l"><span class="id" title="constructor">poly_l</span></a></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span> represents the injection of <span class="inlinecode"><span class="id" title="var">Q</span></span>, a
  polynomial on <span class="inlinecode"><span class="id" title="var">n</span></span> variables, as a polynomial on <span class="inlinecode"><span class="id" title="var">n</span>+1</span> variables.

</li>
<li> Finally, <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_s"><span class="id" title="constructor">poly_s</span></a></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly"><span class="id" title="inductive">poly</span></a></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">(<a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> represents 
  where <span class="inlinecode"><span class="id" title="var">P</span></span> cannot mention the variable  but <span class="inlinecode"><span class="id" title="var">Q</span></span> can mention
  the variables up to and including , and the multiplication is
  not trivial as <span class="inlinecode"><span class="id" title="var">Q</span></span> is non-null.

</li>
</ul>

<div class="paragraph"> </div>

These indices enforce a canonical
representation by ordering the multiplications of the variables.  A
similar encoding is actually used in the <span class="inlinecode"><span class="id" title="tactic">ring</span></span> tactic of <span class="inlinecode"><span class="id" title="var">Coq</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Derive</span> <span class="id" title="var">Signature</span> <span class="id" title="var">NoConfusion</span> <span class="id" title="var">NoConfusionHom</span> <span class="id" title="keyword">for</span> <span class="id" title="var">poly</span>.<br/>
<span class="id" title="keyword">Derive</span> <span class="id" title="var">Subterm</span> <span class="id" title="keyword">for</span> <span class="id" title="var">poly</span>.<br/>

<br/>
</div>

<div class="doc">
In addition to the usual eliminators of the inductive type
  generated by <span class="inlinecode"><span class="id" title="var">Coq</span></span>, we automatically derive a few constructions on
  this <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly"><span class="id" title="inductive">poly</span></a></span> datatype, and the <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#mono"><span class="id" title="inductive">mono</span></a></span> datatype that follows, 
  that will be used by the <span class="inlinecode"><span class="id" title="keyword">Equations</span></span> command:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Its <span class="inlinecode"><span class="id" title="library">Signature</span></span>: as described earlier , this is
  the packing of a polynomial with its two indices, a boolean and a
  natural number in this case.

</li>
<li> Its <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Prop.Classes.html#NoConfusion"><span class="id" title="method">NoConfusion</span></a></span> property used to
  simplify equalities between constructors of the <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly"><span class="id" title="inductive">poly</span></a></span> type 
  (equation ).

</li>
<li> Finally, its <span class="inlinecode"><span class="id" title="var">Subterm</span></span> relation, to be used when performing
  well-founded recursion on <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly"><span class="id" title="inductive">poly</span></a></span>. 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab3"></a><h3 class="section">Monomials</h3>


<div class="paragraph"> </div>

  Monomials represent parts of polynoms, and one can compute the
  coefficient constant by which each monomial is multiplied in a given
  polynom. Again the index of a <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#mono"><span class="id" title="inductive">mono</span></a></span> gives the number of its free variables. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">mono</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">mono_z</span> : <span class="id" title="var">mono</span> <span class="id" title="var">O</span><br/>
| <span class="id" title="var">mono_l</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>}, <span class="id" title="var">mono</span> <span class="id" title="var">n</span> → <span class="id" title="var">mono</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)<br/>
| <span class="id" title="var">mono_s</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>}, <span class="id" title="var">mono</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) → <span class="id" title="var">mono</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">Derive</span> <span class="id" title="var">Signature</span> <span class="id" title="var">NoConfusion</span> <span class="id" title="var">NoConfusionHom</span> <span class="id" title="var">Subterm</span> <span class="id" title="keyword">for</span> <span class="id" title="var">mono</span>.<br/>

<br/>
</div>

<div class="doc">
Our first interesting definition computes the coefficient in <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Numbers.BinNums.html#Z"><span class="id" title="inductive">Z</span></a></span> by which
    a monomial <span class="inlinecode"><span class="id" title="var">m</span></span> is multiplied in a polynomial <span class="inlinecode"><span class="id" title="var">p</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">get_coef</span> {<span class="id" title="var">n</span>} (<span class="id" title="var">m</span> : <span class="id" title="var">mono</span> <span class="id" title="var">n</span>) {<span class="id" title="var">b</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span>) : <span class="id" title="var">Z</span> <span class="id" title="tactic">by</span> <span class="id" title="keyword">wf</span> (<span class="id" title="var">pack</span> <span class="id" title="var">m</span>) <span class="id" title="var">mono_subterm</span> :=<br/>
<span class="id" title="var">get_coef</span> <span class="id" title="var">mono_z</span>     <span class="id" title="var">poly_z</span>       := 0%<span class="id" title="var">Z</span>;<br/>
<span class="id" title="var">get_coef</span> <span class="id" title="var">mono_z</span>     (<span class="id" title="var">poly_c</span> <span class="id" title="var">z</span> <span class="id" title="var">_</span>) := <span class="id" title="var">z</span>;<br/>
<span class="id" title="var">get_coef</span> (<span class="id" title="var">mono_l</span> <span class="id" title="var">m</span>) (<span class="id" title="var">poly_l</span> <span class="id" title="var">p</span>)   := <span class="id" title="var">get_coef</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>;<br/>
<span class="id" title="var">get_coef</span> (<span class="id" title="var">mono_l</span> <span class="id" title="var">m</span>) (<span class="id" title="var">poly_s</span> <span class="id" title="var">p</span> <span class="id" title="var">_</span>) := <span class="id" title="var">get_coef</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>;<br/>
<span class="id" title="var">get_coef</span> (<span class="id" title="var">mono_s</span> <span class="id" title="var">m</span>) (<span class="id" title="var">poly_l</span> <span class="id" title="var">_</span>)   := 0%<span class="id" title="var">Z</span>;<br/>
<span class="id" title="var">get_coef</span> (<span class="id" title="var">mono_s</span> <span class="id" title="var">m</span>) (<span class="id" title="var">poly_s</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>) := <span class="id" title="var">get_coef</span> <span class="id" title="var">m</span> <span class="id" title="var">p2</span>.<br/>

<br/>
</div>

<div class="doc">
The definition can be done using either the usual structural
  recursion of <span class="inlinecode"><span class="id" title="var">Coq</span></span> or well-founded recursion. If we use structural
  recursion, the guardness check might not be able to verify the
  automatically generated proof that the function respects its graph, as
  it involves too much rewriting due to dependent pattern-matching. We
  could prove it using a dependent induction instead of using the raw
  fixpoint combinator as the recursion is on direct subterms of the
  monomial, but in general it could be arbitrarily complicated, so we
  present a version allowing deep pattern-matching and recursion. Note
  that this means we lose the definitional behavior of <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#get_coef"><span class="id" title="definition">get_coef</span></a></span> during
  proofs on open terms, but this can advantageously be replaced using
  explicit <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> calls, providing much more control over
  simplification than the reduction tactics, especially in presence of
  recursive functions. The <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#get_coef"><span class="id" title="definition">get_coef</span></a></span> function still uses no axioms, 
  so it can be used to compute as part of a reflexive tactic for example.

<div class="paragraph"> </div>

  We want to do recursion on the (dependent) <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#mono"><span class="id" title="inductive">mono</span></a></span> <span class="inlinecode"><span class="id" title="var">n</span></span> argument,
  using the derived <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#mono_subterm"><span class="id" title="definition">mono_subterm</span></a></span> relation, which expects an element in
  the signature of <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#mono"><span class="id" title="inductive">mono</span></a></span>, <span class="inlinecode">{</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span> <span class="inlinecode">&amp;</span> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#mono"><span class="id" title="inductive">mono</span></a></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">}</span>, so we use <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#pack"><span class="id" title="abbreviation">pack</span></a></span> <span class="inlinecode"><span class="id" title="var">m</span></span> to
  lift <span class="inlinecode"><span class="id" title="var">m</span></span> into its signature type (<span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#pack"><span class="id" title="abbreviation">pack</span></a></span> is just an abbreviation for
  the <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Signature.html#signature_pack"><span class="id" title="definition">signature_pack</span></a></span> overloaded constant defined in ).

<div class="paragraph"> </div>

  The rest of the definition is standard: to fetch a monomial
  coefficient, we simultaneously pattern-match on the monomial and
  polynomial. Note that many cases are impossible due to the invariants
  enforced in <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly"><span class="id" title="inductive">poly</span></a></span> and <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#mono"><span class="id" title="inductive">mono</span></a></span>. For example <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#mono_z"><span class="id" title="constructor">mono_z</span></a></span> can only match
  polynomials built from <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_z"><span class="id" title="constructor">poly_z</span></a></span> or <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_c"><span class="id" title="constructor">poly_c</span></a></span>, etc. 
<div class="paragraph"> </div>

<a id="lab4"></a><h3 class="section">Two detailed proofs</h3>


<div class="paragraph"> </div>

  The monomial decomposition is actually a complete characterization
  of a polynomial: two polynomials with the same coefficients for every
  monomial are the same. 
<div class="paragraph"> </div>

 To show this, we need a lemma that shows that every non-null polynomial,
    has a monomial with non-null coefficient:
    this proof is done by dependent induction on the polynomial <span class="inlinecode"><span class="id" title="var">p</span></span>.
    Note that the index of <span class="inlinecode"><span class="id" title="var">p</span></span> rules out the <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_z"><span class="id" title="constructor">poly_z</span></a></span> case. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">poly_nz</span> {<span class="id" title="var">n</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">poly</span> <span class="id" title="var">false</span> <span class="id" title="var">n</span>) : <span class="id" title="tactic">∃</span> <span class="id" title="var">m</span>, <span class="id" title="var">IsNZ</span> (<span class="id" title="var">get_coef</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>).<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">with</span> (<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">get_coef</span>; <span class="id" title="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">depind</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">mono_z</span>...<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">IHp</span>. <span class="id" title="tactic">∃</span> (<span class="id" title="var">mono_l</span> <span class="id" title="var">x</span>)...<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">IHp2</span>. <span class="id" title="tactic">∃</span> (<span class="id" title="var">mono_s</span> <span class="id" title="var">x</span>)...<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot; ( x ; p ) " := (<span class="id" title="var">existT</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">p</span>).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">get_coef_eq</span> {<span class="id" title="var">n</span>} <span class="id" title="var">b1</span> <span class="id" title="var">b2</span><br/>
&nbsp;&nbsp;(<span class="id" title="var">p1</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b1</span> <span class="id" title="var">n</span>) (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> <span class="id" title="var">n</span>) :<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> (<span class="id" title="var">m</span> : <span class="id" title="var">mono</span> <span class="id" title="var">n</span>), <span class="id" title="var">get_coef</span> <span class="id" title="var">m</span> <span class="id" title="var">p1</span> = <span class="id" title="var">get_coef</span> <span class="id" title="var">m</span> <span class="id" title="var">p2</span>) →<br/>
&nbsp;&nbsp;(<span class="id" title="var">b1</span> ; <span class="id" title="var">p1</span>) = (<span class="id" title="var">b2</span> ; <span class="id" title="var">p2</span>) :&gt; { <span class="id" title="var">null</span> : <span class="id" title="var">_</span> &amp; <span class="id" title="var">poly</span> <span class="id" title="var">null</span> <span class="id" title="var">n</span>}.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">simp</span> <span class="id" title="var">get_coef</span> <span class="id" title="tactic">in</span> *; <span class="id" title="tactic">auto</span>).<br/>

<br/>
</div>

<div class="doc">
Throughout the proof, we use the <span class="inlinecode"><span class="id" title="var">simp</span></span> tactic defined by
       which is a wrapper around <span class="inlinecode"><span class="id" title="tactic">autorewrite</span></span> using the hint
      database associated to the constant <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#get_coef"><span class="id" title="definition">get_coef</span></a></span>: the database
      contains the defining equations of <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#get_coef"><span class="id" title="definition">get_coef</span></a></span> as rewrite rules
      that can be used to simplify calls to <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#get_coef"><span class="id" title="definition">get_coef</span></a></span> in the goal. 
</div>
<div class="code">

<br/>
<span class="id" title="tactic">intros</span> <span class="id" title="var">Hcoef</span>.<br/>
<span class="id" title="tactic">induction</span> <span class="id" title="var">p1</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">z</span> <span class="id" title="var">Hz</span> | <span class="id" title="var">n</span> <span class="id" title="var">b</span> <span class="id" title="var">p1</span> | <span class="id" title="var">n</span> <span class="id" title="var">b</span> <span class="id" title="var">p1</span> <span class="id" title="var">IHp</span> <span class="id" title="var">q1</span> <span class="id" title="var">IHq</span> ]<br/>
&nbsp;&nbsp;<span class="id" title="tactic">in</span> <span class="id" title="var">b2</span>, <span class="id" title="var">p2</span>, <span class="id" title="var">Hcoef</span> |- *;<br/>
[<span class="id" title="tactic">dependent</span> <span class="id" title="var">elimination</span> <span class="id" title="var">p2</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">poly_z</span> | <span class="id" title="var">poly_c</span> <span class="id" title="var">z</span> <span class="id" title="var">i</span>] |<br/>
&nbsp;<span class="id" title="tactic">dependent</span> <span class="id" title="var">elimination</span> <span class="id" title="var">p2</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">poly_z</span> | <span class="id" title="var">poly_c</span> <span class="id" title="var">z'</span> <span class="id" title="var">i'</span>] |<br/>
&nbsp;<span class="id" title="tactic">dependent</span> <span class="id" title="var">elimination</span> <span class="id" title="var">p2</span> <span class="id" title="keyword">as</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[@<span class="id" title="var">poly_l</span> <span class="id" title="var">n</span> <span class="id" title="var">b'</span> <span class="id" title="var">p2</span> | @<span class="id" title="var">poly_s</span> <span class="id" title="var">n</span> <span class="id" title="var">b'</span> <span class="id" title="var">p2</span> <span class="id" title="var">q2</span>] ..].<br/>
&nbsp;&nbsp;<span class="id" title="var">all</span>:(<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">rename</span> <span class="id" title="var">n0</span> <span class="id" title="var">into</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">auto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">try</span> (<span class="id" title="tactic">specialize</span> (<span class="id" title="var">Hcoef</span> <span class="id" title="var">mono_z</span>); <span class="id" title="var">simp</span> <span class="id" title="var">get_coef</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hcoef</span>; <span class="id" title="tactic">subst</span> <span class="id" title="var">z</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">elim</span> <span class="id" title="var">i</span> || <span class="id" title="tactic">elim</span> <span class="id" title="var">Hz</span> ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">f_equal</span>; <span class="id" title="tactic">auto</span>)); <span class="id" title="tactic">fail</span>)).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHp1</span> <span class="id" title="var">_</span> <span class="id" title="var">p2</span>). <span class="id" title="var">forward</span> <span class="id" title="var">IHp1</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">Hcoef</span> (<span class="id" title="var">mono_l</span> <span class="id" title="var">m</span>))... <span class="id" title="tactic">clear</span> <span class="id" title="var">Hcoef</span>.<br/>

<br/>
</div>

<div class="doc">
We first do an induction on <span class="inlinecode"><span class="id" title="var">p1</span></span> and then eliminate (dependently)
        <span class="inlinecode"><span class="id" title="var">p2</span></span>, the first two branches need to consider variable-closed <span class="inlinecode"><span class="id" title="var">p2</span></span>s
        while the next two branches have <span class="inlinecode"><span class="id" title="var">p2</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly"><span class="id" title="inductive">poly</span></a></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">(<a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>, hence the <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_l"><span class="id" title="constructor">poly_l</span></a></span> 
        and <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_s"><span class="id" title="constructor">poly_s</span></a></span> patterns. The elided rest of the tactic solves simple subgoals. 

<div class="paragraph"> </div>

      We now focus on the case for <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_l"><span class="id" title="constructor">poly_l</span></a></span> on both sides. 
      After some simplifications of the induction hypothesis using 
      the <span class="inlinecode"><span class="id" title="var">Hcoef</span></span> hypothesis, we get to the following goal:
<br/>
<span class="inlinecode">&nbsp;&nbsp;(<span class="id" title="var">b</span>, <span class="id" title="var">b'</span> : <a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>) (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<span class="id" title="var">p1</span> : <a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly"><span class="id" title="inductive">poly</span></a> <span class="id" title="var">b</span> <span class="id" title="var">n</span>) (<span class="id" title="var">p2</span> : <a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly"><span class="id" title="inductive">poly</span></a> <span class="id" title="var">b'</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;<span class="id" title="var">IHp1</span> : (<span class="id" title="var">b</span>; <span class="id" title="var">p1</span>) = (<span class="id" title="var">b'</span>; <span class="id" title="var">p2</span>)<br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;(<span class="id" title="var">b</span>; <a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_l"><span class="id" title="constructor">poly_l</span></a> <span class="id" title="var">p1</span>) = (<span class="id" title="var">b'</span>; <a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_l"><span class="id" title="constructor">poly_l</span></a> <span class="id" title="var">p2</span>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

  The <span class="inlinecode"><span class="id" title="var">IHp1</span></span> hypothesis, as a general equality between dependent 
  pairs can again be eliminated dependently to substitute <span class="inlinecode"><span class="id" title="var">b'</span></span> by 
  <span class="inlinecode"><span class="id" title="var">b</span></span> and <span class="inlinecode"><span class="id" title="var">p2</span></span> by <span class="inlinecode"><span class="id" title="var">p1</span></span> simultaneously, using 
  <span class="inlinecode"><span class="id" title="tactic">dependent</span></span> <span class="inlinecode"><span class="id" title="var">elimination</span></span> <span class="inlinecode"><span class="id" title="var">IHp1</span></span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[<a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Init.Logic.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a>]</span>, leaving us with 
  a trivial subgoal. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
The next step is to give an evaluation semantics to polynomials.
    We program <span class="inlinecode"><span class="id" title="tactic">eval</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> where <span class="inlinecode"><span class="id" title="var">v</span></span> is a valuation in <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Numbers.BinNums.html#Z"><span class="id" title="inductive">Z</span></a></span> for all the
    variables in <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly"><span class="id" title="inductive">poly</span></a></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="tactic">eval</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span>) (<span class="id" title="var">v</span> : <span class="id" title="var">Vector.t</span> <span class="id" title="var">Z</span> <span class="id" title="var">n</span>) : <span class="id" title="var">Z</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">eval</span> <span class="id" title="var">poly_z</span>         <span class="id" title="var">nil</span>           := 0%<span class="id" title="var">Z</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">eval</span> (<span class="id" title="var">poly_c</span> <span class="id" title="var">z</span> <span class="id" title="var">_</span>)   <span class="id" title="var">nil</span>           := <span class="id" title="var">z</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">eval</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">p</span>)     (<span class="id" title="var">cons</span> <span class="id" title="var">_</span> <span class="id" title="var">xs</span>)   := <span class="id" title="tactic">eval</span> <span class="id" title="var">p</span> <span class="id" title="var">xs</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">eval</span> (<span class="id" title="var">poly_s</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>) (<span class="id" title="var">cons</span> <span class="id" title="var">y</span> <span class="id" title="var">ys</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">eval</span> <span class="id" title="var">p1</span> <span class="id" title="var">ys</span> + <span class="id" title="var">y</span> × <span class="id" title="tactic">eval</span> <span class="id" title="var">p2</span> (<span class="id" title="var">cons</span> <span class="id" title="var">y</span> <span class="id" title="var">ys</span>))%<span class="id" title="var">Z</span>.<br/>

<br/>
</div>

<div class="doc">
It is quite clear that two equal polynomials should have the
    same value for any valuation. To show this, we first need to prove
    that evaluating a null polynomial always computes to <span class="inlinecode">0</span>, whichever
    valuation is used. 
</div>
<div class="code">
</div>

<div class="doc">
This is a typical case where the proof directly follows the definition
  of <span class="inlinecode"><span class="id" title="tactic">eval</span></span>. Instead of redoing the same case splits and induction that
  the function performs, we can directly appeal to its elimination
  principle using the <span class="inlinecode"><span class="id" title="var">funelim</span></span> tactic. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">poly_z_eval</span> {<span class="id" title="var">n</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">poly</span> <span class="id" title="var">true</span> <span class="id" title="var">n</span>) <span class="id" title="var">v</span> : <span class="id" title="tactic">eval</span> <span class="id" title="var">p</span> <span class="id" title="var">v</span> = 0%<span class="id" title="var">Z</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">funelim</span> (<span class="id" title="tactic">eval</span> <span class="id" title="var">p</span> <span class="id" title="var">v</span>); [ <span class="id" title="tactic">reflexivity</span> | <span class="id" title="tactic">assumption</span> ].<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This leaves us with two goals as the <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a></span> index in <span class="inlinecode"><span class="id" title="var">p</span></span> implies
  that the <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_c"><span class="id" title="constructor">poly_c</span></a></span> and <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_s"><span class="id" title="constructor">poly_s</span></a></span> clauses do not need to be considered.
  We have to show <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> for the case <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_z"><span class="id" title="constructor">poly_z</span></a></span> and <span class="inlinecode"><span class="id" title="tactic">eval</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode"><span class="id" title="var">v</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>
  for the <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_l"><span class="id" title="constructor">poly_l</span></a></span> recursive constructor, in which case the conclusion
  directly follows from the induction hypothesis correspondinng to the
  recursive call. The second subgoal is hence discharged with an
  <span class="inlinecode"><span class="id" title="tactic">assumption</span></span> call.

<div class="paragraph"> </div>

  Addition is defined on two polynomials with the same number of variables and returns
  a (possibly null) polynomial with the same number of variables.
  We define an injection function to constructs objects in the dependent pair type
  <span class="inlinecode">{<span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a></span> <span class="inlinecode">&amp;</span> <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly"><span class="id" title="inductive">poly</span></a></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">n</span>}</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">apoly</span> {<span class="id" title="var">n</span> <span class="id" title="var">b</span>} := <span class="id" title="var">existT</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> ⇒ <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span>) <span class="id" title="var">b</span>.<br/>

<br/>
</div>

<div class="doc">
The definition shows the <span class="inlinecode"><span class="id" title="keyword">with</span></span> feature of Equations, allowing to
    add a nested pattern-matching while defining the function, here in
    one case to inject an integer into a polynomial and in the
    <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_s"><span class="id" title="constructor">poly_s</span></a></span>, <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_s"><span class="id" title="constructor">poly_s</span></a></span> case to inspect a recursive call. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot; x .1 " := (<span class="id" title="var">projT1</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Notation</span> &quot; x .2 " := (<span class="id" title="var">projT2</span> <span class="id" title="var">x</span>).<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">plus</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b1</span>} (<span class="id" title="var">p1</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b1</span> <span class="id" title="var">n</span>) {<span class="id" title="var">b2</span>} (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> <span class="id" title="var">n</span>) : { <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> &amp; <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span> } :=<br/>
&nbsp;&nbsp;<span class="id" title="var">plus</span> <span class="id" title="var">poly_z</span>        <span class="id" title="var">poly_z</span>          := <span class="id" title="var">apoly</span> <span class="id" title="var">poly_z</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">plus</span> <span class="id" title="var">poly_z</span>        (<span class="id" title="var">poly_c</span> <span class="id" title="var">y</span> <span class="id" title="var">ny</span>)   := <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_c</span> <span class="id" title="var">y</span> <span class="id" title="var">ny</span>);<br/>
&nbsp;&nbsp;<span class="id" title="var">plus</span> (<span class="id" title="var">poly_c</span> <span class="id" title="var">x</span> <span class="id" title="var">nx</span>) <span class="id" title="var">poly_z</span>          := <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_c</span> <span class="id" title="var">x</span> <span class="id" title="var">nx</span>);<br/>
&nbsp;&nbsp;<span class="id" title="var">plus</span> (<span class="id" title="var">poly_c</span> <span class="id" title="var">x</span> <span class="id" title="var">nx</span>) (<span class="id" title="var">poly_c</span> <span class="id" title="var">y</span> <span class="id" title="var">ny</span>)   <span class="id" title="keyword">with</span> (<span class="id" title="var">x</span> + <span class="id" title="var">y</span>)%<span class="id" title="var">Z</span> ⇒ {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Z0</span> ⇒ <span class="id" title="var">apoly</span> <span class="id" title="var">poly_z</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Zpos</span> <span class="id" title="var">z'</span> ⇒ <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_c</span> (<span class="id" title="var">Zpos</span> <span class="id" title="var">z'</span>) <span class="id" title="var">I</span>) ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Zneg</span> <span class="id" title="var">z'</span> ⇒ <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_c</span> (<span class="id" title="var">Zneg</span> <span class="id" title="var">z'</span>) <span class="id" title="var">I</span>) };<br/>
&nbsp;&nbsp;<span class="id" title="var">plus</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">p1</span>)    (<span class="id" title="var">poly_l</span> <span class="id" title="var">p2</span>)    := <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_l</span> (<span class="id" title="var">plus</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>).2);<br/>
&nbsp;&nbsp;<span class="id" title="var">plus</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">p1</span>)    (<span class="id" title="var">poly_s</span> <span class="id" title="var">p2</span> <span class="id" title="var">q2</span>) := <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_s</span> (<span class="id" title="var">plus</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>).2 <span class="id" title="var">q2</span>);<br/>
&nbsp;&nbsp;<span class="id" title="var">plus</span> (<span class="id" title="var">poly_s</span> <span class="id" title="var">p1</span> <span class="id" title="var">q1</span>) (<span class="id" title="var">poly_l</span> <span class="id" title="var">p2</span>)    := <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_s</span> (<span class="id" title="var">plus</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>).2 <span class="id" title="var">q1</span>);<br/>
<br/>
&nbsp;&nbsp;<span class="id" title="var">plus</span> (<span class="id" title="var">poly_s</span> <span class="id" title="var">p1</span> <span class="id" title="var">q1</span>) (<span class="id" title="var">poly_s</span> <span class="id" title="var">p2</span> <span class="id" title="var">q2</span>) <span class="id" title="keyword">with</span> <span class="id" title="var">plus</span> <span class="id" title="var">q1</span> <span class="id" title="var">q2</span> ⇒ {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id" title="var">false</span> ; <span class="id" title="var">q3</span>) ⇒ <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_s</span> (<span class="id" title="var">plus</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>).2 <span class="id" title="var">q3</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id" title="var">true</span>  ; <span class="id" title="var">_</span>)  ⇒ <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_l</span> (<span class="id" title="var">plus</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>).2) }.<br/>

<br/>
</div>

<div class="doc">
The functional elimination principle can be derived all the same
    for <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#plus"><span class="id" title="definition">plus</span></a></span>, allowing us to make quick work of the proof that it
    is a morphism for evaluation: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_eval</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b1</span>} (<span class="id" title="var">p1</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b1</span> <span class="id" title="var">n</span>) {<span class="id" title="var">b2</span>} (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> <span class="id" title="var">n</span>) <span class="id" title="var">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">eval</span> <span class="id" title="var">p1</span> <span class="id" title="var">v</span> + <span class="id" title="tactic">eval</span> <span class="id" title="var">p2</span> <span class="id" title="var">v</span>)%<span class="id" title="var">Z</span> = <span class="id" title="tactic">eval</span> (<span class="id" title="var">plus</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>).2 <span class="id" title="var">v</span>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">simp</span> <span class="id" title="var">plus</span> <span class="id" title="tactic">eval</span>; <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">zarith</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">X</span> := (<span class="id" title="var">simp</span> <span class="id" title="var">plus</span> <span class="id" title="tactic">eval</span>; <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">zarith</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="tactic">until</span> <span class="id" title="var">p2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">f</span> := <span class="id" title="keyword">constr</span>:(<span class="id" title="var">fun_elim</span> (<span class="id" title="var">f</span>:=@<span class="id" title="var">plus</span>)) <span class="id" title="tactic">in</span> <span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">v</span>; <span class="id" title="var">X</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>; <span class="id" title="var">X</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Heq</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">Hind</span> (<span class="id" title="var">Vector.cons</span> <span class="id" title="var">h</span> <span class="id" title="var">v</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">poly_z_eval</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hind</span>. <span class="id" title="var">nia</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Heq</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hind</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">Hind</span>. <span class="id" title="var">nia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Rewrite</span> &lt;- @<span class="id" title="var">plus_eval</span> : <span class="id" title="tactic">eval</span>.<br/>

<br/>
</div>

<div class="doc">
We skip the rest of the operations definition, <span class="inlinecode"><span class="id" title="var">poly_mult</span></span>, <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_neg"><span class="id" title="definition">poly_neg</span></a></span> and
    <span class="inlinecode"><span class="id" title="var">poly_substract</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">poly_neg</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span>) : <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">poly_neg</span> <span class="id" title="var">poly_z</span> := <span class="id" title="var">poly_z</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">poly_neg</span> (<span class="id" title="var">poly_c</span> (<span class="id" title="var">Z.pos</span> <span class="id" title="var">a</span>) <span class="id" title="var">p</span>) := <span class="id" title="var">poly_c</span> (<span class="id" title="var">Z.neg</span> <span class="id" title="var">a</span>) <span class="id" title="var">p</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">poly_neg</span> (<span class="id" title="var">poly_c</span> (<span class="id" title="var">Z.neg</span> <span class="id" title="var">a</span>) <span class="id" title="var">p</span>) := <span class="id" title="var">poly_c</span> (<span class="id" title="var">Z.pos</span> <span class="id" title="var">a</span>) <span class="id" title="var">p</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">poly_neg</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">p</span>) := <span class="id" title="var">poly_l</span> (<span class="id" title="var">poly_neg</span> <span class="id" title="var">p</span>);<br/>
&nbsp;&nbsp;<span class="id" title="var">poly_neg</span> (<span class="id" title="var">poly_s</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span>) := <span class="id" title="var">poly_s</span> (<span class="id" title="var">poly_neg</span> <span class="id" title="var">p</span>) (<span class="id" title="var">poly_neg</span> <span class="id" title="var">q</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">neg_eval</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b1</span>} (<span class="id" title="var">p1</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b1</span> <span class="id" title="var">n</span>) <span class="id" title="var">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(- <span class="id" title="tactic">eval</span> <span class="id" title="var">p1</span> <span class="id" title="var">v</span>)%<span class="id" title="var">Z</span> = <span class="id" title="tactic">eval</span> (<span class="id" title="var">poly_neg</span> <span class="id" title="var">p1</span>) <span class="id" title="var">v</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">XX</span> := (<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">poly_neg</span> <span class="id" title="var">plus</span> <span class="id" title="tactic">eval</span>; <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">zarith</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">depind</span> <span class="id" title="var">p1</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">v</span>; <span class="id" title="var">XX</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">z</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">i</span>; <span class="id" title="var">XX</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHp1_1</span>; <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHp1_2</span>; <span class="id" title="var">nia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Rewrite</span> &lt;- @<span class="id" title="var">neg_eval</span> : <span class="id" title="tactic">eval</span>.<br/>

<br/>
</div>

<div class="doc">
Equality can be decided using the difference of polynoms 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">poly_diff_z_eq</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b1</span>} (<span class="id" title="var">p1</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b1</span> <span class="id" title="var">n</span>) {<span class="id" title="var">b2</span>} (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">plus</span> <span class="id" title="var">p1</span> (<span class="id" title="var">poly_neg</span> <span class="id" title="var">p2</span>)).1 = <span class="id" title="var">true</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">_</span> ; <span class="id" title="var">p1</span>) = (<span class="id" title="var">_</span>; <span class="id" title="var">p2</span>) :&gt; { <span class="id" title="var">null</span> : <span class="id" title="var">bool</span> &amp; <span class="id" title="var">poly</span> <span class="id" title="var">null</span> <span class="id" title="var">n</span> }.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">depind</span> <span class="id" title="var">p1</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">p2</span>; <span class="id" title="tactic">auto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">try</span> (<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">poly_neg</span> <span class="id" title="var">plus</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">discriminate</span>; <span class="id" title="tactic">fail</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">z</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">i</span>; <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">poly_neg</span> <span class="id" title="var">plus</span> <span class="id" title="tactic">in</span> *; <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">f_equal</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">z</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">z</span> | <span class="id" title="var">z</span>], <span class="id" title="var">z0</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">z0</span> | <span class="id" title="var">z0</span> ]; <span class="id" title="var">depelim</span> <span class="id" title="var">i</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">i0</span>; <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">poly_neg</span> <span class="id" title="var">plus</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">z</span> = <span class="id" title="var">z0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">Z.pos</span> <span class="id" title="var">z</span> + <span class="id" title="var">Z.neg</span> <span class="id" title="var">z0</span>)%<span class="id" title="var">Z</span> <span class="id" title="keyword">as</span> <span class="id" title="var">z1</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">z1</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">discriminate</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>; <span class="id" title="var">nia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">Z.pos</span> <span class="id" title="var">z</span> + <span class="id" title="var">Z.pos</span> <span class="id" title="var">z0</span>)%<span class="id" title="var">Z</span> <span class="id" title="keyword">as</span> <span class="id" title="var">z1</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">z1</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">Z.neg</span> <span class="id" title="var">z</span> + <span class="id" title="var">Z.neg</span> <span class="id" title="var">z0</span>)%<span class="id" title="var">Z</span> <span class="id" title="keyword">as</span> <span class="id" title="var">z1</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">z1</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">z</span> = <span class="id" title="var">z0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">Z.neg</span> <span class="id" title="var">z</span> + <span class="id" title="var">Z.pos</span> <span class="id" title="var">z0</span>)%<span class="id" title="var">Z</span> <span class="id" title="keyword">as</span> <span class="id" title="var">z1</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">z1</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">discriminate</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>; <span class="id" title="var">nia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">poly_neg</span> <span class="id" title="var">plus</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHp1</span> <span class="id" title="var">_</span> <span class="id" title="var">p2</span> <span class="id" title="var">H</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">depelim</span> <span class="id" title="var">IHp1</span>. <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">poly_neg</span> <span class="id" title="var">plus</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHp1_1</span> <span class="id" title="var">_</span> <span class="id" title="var">p2_1</span>); <span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHp1_2</span> <span class="id" title="var">_</span> <span class="id" title="var">p2_2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">plus</span> <span class="id" title="var">p1_2</span> (<span class="id" title="var">poly_neg</span> <span class="id" title="var">p2_2</span>)) <span class="id" title="keyword">as</span> <span class="id" title="var">P</span>; <span class="id" title="var">remember</span> (<span class="id" title="var">plus</span> <span class="id" title="var">p1_1</span> (<span class="id" title="var">poly_neg</span> <span class="id" title="var">p2_1</span>)) <span class="id" title="keyword">as</span> <span class="id" title="var">Q</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">P</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">bP</span> <span class="id" title="var">P</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">Q</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">bQ</span> <span class="id" title="var">Q</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">bP</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">bQ</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">HeqQ</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHp1_1</span> <span class="id" title="var">eq_refl</span>); <span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHp1_2</span> <span class="id" title="var">eq_refl</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">depelim</span> <span class="id" title="var">IHp1_1</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">depelim</span> <span class="id" title="var">IHp1_2</span>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab5"></a><h3 class="section">Two polynomials with the same values are syntacically equal.</h3>

 This is shown using <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_nz_eval"><span class="id" title="lemma">poly_nz_eval</span></a></span>: the difference of two polynomials with the same values is null.
 Then use <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_diff_z_eq"><span class="id" title="lemma">poly_diff_z_eq</span></a></span>
 
</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">poly_eval_eq</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b1</span>} (<span class="id" title="var">p1</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b1</span> <span class="id" title="var">n</span>) {<span class="id" title="var">b2</span>} (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">v</span>, <span class="id" title="tactic">eval</span> <span class="id" title="var">p1</span> <span class="id" title="var">v</span> = <span class="id" title="tactic">eval</span> <span class="id" title="var">p2</span> <span class="id" title="var">v</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">b1</span> ; <span class="id" title="var">p1</span>) = (<span class="id" title="var">b2</span>; <span class="id" title="var">p2</span>) :&gt; { <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> &amp; <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span>}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">plus</span> <span class="id" title="var">p1</span> (<span class="id" title="var">poly_neg</span> <span class="id" title="var">p2</span>)) <span class="id" title="keyword">as</span> <span class="id" title="var">P</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">P</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">b</span> <span class="id" title="var">P</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">poly_diff_z_eq</span>; <span class="id" title="tactic">inversion</span> <span class="id" title="var">HeqP</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">exfalso</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (@<span class="id" title="var">poly_nz_eval</span> <span class="id" title="var">n</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">H0</span> <span class="id" title="var">_</span>]; <span class="id" title="tactic">destruct</span> (<span class="id" title="var">H0</span> <span class="id" title="var">P</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">v</span> <span class="id" title="var">H1</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="tactic">eval</span> <span class="id" title="var">P</span> <span class="id" title="var">v</span> = <span class="id" title="tactic">eval</span> (<span class="id" title="var">plus</span> <span class="id" title="var">p1</span> (<span class="id" title="var">poly_neg</span> <span class="id" title="var">p2</span>)).2 <span class="id" title="var">v</span>); [<span class="id" title="tactic">inversion</span> <span class="id" title="var">HeqP</span>; <span class="id" title="tactic">auto</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H2</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>; <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="tactic">eval</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>; <span class="id" title="tactic">rewrite</span> (<span class="id" title="var">H</span> <span class="id" title="var">v</span>) <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IsNZ_spec</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab6"></a><h3 class="section">Multiplication of polynomials</h3>


<div class="paragraph"> </div>

  This definition is a bit more laborious as there are inductive cases to treat on the second argument:
  it is not a simple structurally recursive definition.
 
<div class="paragraph"> </div>

 The <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_l_or_s"><span class="id" title="definition">poly_l_or_s</span></a></span> definition is a smart constructor to construct
    <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">q</span></span> when <span class="inlinecode"><span class="id" title="var">q</span></span> can be null. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">poly_l_or_s</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b1</span>} (<span class="id" title="var">p1</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b1</span> <span class="id" title="var">n</span>) {<span class="id" title="var">b2</span>} (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) :<br/>
&nbsp;&nbsp;{<span class="id" title="var">b</span> : <span class="id" title="var">bool</span> &amp; <span class="id" title="var">poly</span> <span class="id" title="var">b</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)} :=<br/>
<span class="id" title="var">poly_l_or_s</span> <span class="id" title="var">p1</span> (<span class="id" title="var">b2</span> := <span class="id" title="var">true</span>) <span class="id" title="var">p2</span> := <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">p1</span>);<br/>
<span class="id" title="var">poly_l_or_s</span> <span class="id" title="var">p1</span> (<span class="id" title="var">b2</span> := <span class="id" title="var">false</span>) <span class="id" title="var">p2</span> := <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_s</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">poly_l_or_s_eval</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b1</span>} (<span class="id" title="var">p1</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b1</span> <span class="id" title="var">n</span>) {<span class="id" title="var">b2</span>} (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) <span class="id" title="var">h</span> <span class="id" title="var">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eval</span> (<span class="id" title="var">poly_l_or_s</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>).2 (<span class="id" title="var">Vector.cons</span> <span class="id" title="var">h</span> <span class="id" title="var">v</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">eval</span> <span class="id" title="var">p1</span> <span class="id" title="var">v</span> + <span class="id" title="var">h</span> × <span class="id" title="tactic">eval</span> <span class="id" title="var">p2</span> (<span class="id" title="var">Vector.cons</span> <span class="id" title="var">h</span> <span class="id" title="var">v</span>))%<span class="id" title="var">Z</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">funelim</span> (<span class="id" title="var">poly_l_or_s</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>); <span class="id" title="var">simp</span> <span class="id" title="tactic">eval</span>; <span class="id" title="tactic">trivial</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">poly_z_eval</span>. <span class="id" title="var">nia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Rewrite</span> @<span class="id" title="var">poly_l_or_s_eval</span> : <span class="id" title="tactic">eval</span>.<br/>

<br/>
<span class="comment">(*&nbsp;<span class="inlinecode"><span class="id" title="var">mult</span></span> <span class="inlinecode">(<span class="id" title="var">poly_l</span></span> <span class="inlinecode"><span class="id" title="var">p</span>)</span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">mult_l</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">(<span class="id" title="var">mult</span></span> <span class="inlinecode"><span class="id" title="var">p</span>)</span>&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">mult_l</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b2</span>} (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) (<span class="id" title="var">m</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">b2</span>} (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> <span class="id" title="var">n</span>), { <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> &amp; <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span> }) :<br/>
&nbsp;&nbsp;{ <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> &amp; <span class="id" title="var">poly</span> <span class="id" title="var">b</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) } :=<br/>
&nbsp;&nbsp;<span class="id" title="var">mult_l</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">p2</span>) <span class="id" title="var">m</span> := <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_l</span> (<span class="id" title="var">m</span> <span class="id" title="var">_</span> <span class="id" title="var">p2</span>).2);<br/>
&nbsp;&nbsp;<span class="id" title="var">mult_l</span> (<span class="id" title="var">poly_s</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>) <span class="id" title="var">m</span> := <span class="id" title="var">poly_l_or_s</span> (<span class="id" title="var">m</span> <span class="id" title="var">_</span> <span class="id" title="var">p1</span>).2 (<span class="id" title="var">mult_l</span> <span class="id" title="var">p2</span> <span class="id" title="var">m</span>).2.<br/>

<br/>
<span class="comment">(*&nbsp;<span class="inlinecode"><span class="id" title="var">mult</span></span> <span class="inlinecode">(<span class="id" title="var">poly_s</span></span> <span class="inlinecode"><span class="id" title="var">p1</span></span> <span class="inlinecode"><span class="id" title="var">p2</span>)</span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">mult_s</span></span> <span class="inlinecode"><span class="id" title="var">q</span></span> <span class="inlinecode">(<span class="id" title="var">mult</span></span> <span class="inlinecode"><span class="id" title="var">p1</span>)</span> <span class="inlinecode">(<span class="id" title="var">mult</span></span> <span class="inlinecode"><span class="id" title="var">p2</span>)</span>&nbsp;*)</span><br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">mult_s</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b2</span>} (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">m1</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">b2</span>} (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> <span class="id" title="var">n</span>), { <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> &amp; <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span> })<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">m2</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">b2</span>} (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)), { <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> &amp; <span class="id" title="var">poly</span> <span class="id" title="var">b</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) }) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> &amp; <span class="id" title="var">poly</span> <span class="id" title="var">b</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) } :=<br/>
&nbsp;&nbsp;<span class="id" title="var">mult_s</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">p1</span>) <span class="id" title="var">m1</span> <span class="id" title="var">m2</span> := <span class="id" title="var">poly_l_or_s</span> (<span class="id" title="var">m1</span> <span class="id" title="var">_</span> <span class="id" title="var">p1</span>).2 (<span class="id" title="var">m2</span> <span class="id" title="var">_</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">p1</span>)).2;<br/>
&nbsp;&nbsp;<span class="id" title="var">mult_s</span> (<span class="id" title="var">poly_s</span> <span class="id" title="var">p2</span> <span class="id" title="var">q2</span>) <span class="id" title="var">m1</span> <span class="id" title="var">m2</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">poly_l_or_s</span> (<span class="id" title="var">m1</span> <span class="id" title="var">_</span> <span class="id" title="var">p2</span>).2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">plus</span> (<span class="id" title="var">m2</span> <span class="id" title="var">_</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">p2</span>)).2 (<span class="id" title="var">mult_s</span> <span class="id" title="var">q2</span> <span class="id" title="var">m1</span> <span class="id" title="var">m2</span>).2).2.<br/>

<br/>
</div>

<div class="doc">
Finally, the multiplication definition. This relies on the
   guard condition being able to unfold the definitions of <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#mult_l"><span class="id" title="definition">mult_l</span></a></span> and <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#mult_s"><span class="id" title="definition">mult_s</span></a></span> to
   see that multiplication is well-guarded. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">mult</span> <span class="id" title="var">n</span> <span class="id" title="var">b1</span> (<span class="id" title="var">p1</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b1</span> <span class="id" title="var">n</span>) <span class="id" title="var">b2</span> (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> <span class="id" title="var">n</span>) : { <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> &amp; <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span> } :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mult</span> ?(0) ?(<span class="id" title="var">true</span>) <span class="id" title="var">poly_z</span>        <span class="id" title="var">b2</span> <span class="id" title="var">_</span> := <span class="id" title="var">apoly</span> <span class="id" title="var">poly_z</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mult</span> ?(0) ?(<span class="id" title="var">false</span>) (<span class="id" title="var">poly_c</span> <span class="id" title="var">x</span> <span class="id" title="var">nx</span>) ?(<span class="id" title="var">true</span>) <span class="id" title="var">poly_z</span> := <span class="id" title="var">apoly</span> <span class="id" title="var">poly_z</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mult</span> ?(0) ?(<span class="id" title="var">false</span>) (<span class="id" title="var">poly_c</span> <span class="id" title="var">x</span> <span class="id" title="var">nx</span>) ?(<span class="id" title="var">false</span>) (<span class="id" title="var">poly_c</span> <span class="id" title="var">y</span> <span class="id" title="var">ny</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> (<span class="id" title="var">x</span> × <span class="id" title="var">y</span>)%<span class="id" title="var">Z</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Z0</span> ⇒ <span class="id" title="var">apoly</span> <span class="id" title="var">poly_z</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Zpos</span> <span class="id" title="var">z'</span> ⇒ <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_c</span> (<span class="id" title="var">Zpos</span> <span class="id" title="var">z'</span>) <span class="id" title="var">I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Zneg</span> <span class="id" title="var">z'</span> ⇒ <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_c</span> (<span class="id" title="var">Zneg</span> <span class="id" title="var">z'</span>) <span class="id" title="var">I</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mult</span> ?(<span class="id" title="var">S</span> <span class="id" title="var">n</span>) ?(<span class="id" title="var">b</span>) (@<span class="id" title="var">poly_l</span> <span class="id" title="var">n</span> <span class="id" title="var">b</span> <span class="id" title="var">p1</span>)    <span class="id" title="var">b2</span> <span class="id" title="var">q</span> := <span class="id" title="var">mult_l</span> <span class="id" title="var">q</span> (<span class="id" title="var">mult</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">p1</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mult</span> ?(<span class="id" title="var">S</span> <span class="id" title="var">n</span>) ?(<span class="id" title="var">false</span>) (@<span class="id" title="var">poly_s</span> <span class="id" title="var">n</span> <span class="id" title="var">b</span> <span class="id" title="var">p1</span> <span class="id" title="var">q1</span>) <span class="id" title="var">b2</span> <span class="id" title="var">q</span> := <span class="id" title="var">mult_s</span> <span class="id" title="var">q</span> (<span class="id" title="var">mult</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">p1</span>) (<span class="id" title="var">mult</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">q1</span>).<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">mult</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b1</span>} <span class="id" title="var">p1</span> {<span class="id" title="var">b2</span>} <span class="id" title="var">p2</span>.<br/>

<br/>
</div>

<div class="doc">
The proof that multiplication is a morphism for evaluation works as usual by induction,
    using previously proved lemma to get equations in <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Numbers.BinNums.html#Z"><span class="id" title="inductive">Z</span></a></span> that the <span class="inlinecode"><span class="id" title="var">nia</span></span> tactic can handle. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">mult_eval</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b1</span>} (<span class="id" title="var">p1</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b1</span> <span class="id" title="var">n</span>) {<span class="id" title="var">b2</span>} (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> <span class="id" title="var">n</span>) <span class="id" title="var">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">eval</span> <span class="id" title="var">p1</span> <span class="id" title="var">v</span> × <span class="id" title="tactic">eval</span> <span class="id" title="var">p2</span> <span class="id" title="var">v</span>)%<span class="id" title="var">Z</span> = <span class="id" title="tactic">eval</span> (<span class="id" title="var">mult</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>).2 <span class="id" title="var">v</span>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">with</span> (<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">mult</span> <span class="id" title="var">mult_l</span> <span class="id" title="var">mult_s</span> <span class="id" title="tactic">eval</span>; <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">zarith</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">Y</span> := (<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">mult</span> <span class="id" title="var">mult_l</span> <span class="id" title="var">mult_s</span> <span class="id" title="tactic">eval</span>; <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">zarith</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">depind</span> <span class="id" title="var">p1</span>; <span class="id" title="tactic">try</span> (<span class="id" title="var">depind</span> <span class="id" title="var">p2</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">v</span>; <span class="id" title="var">Y</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="var">Y</span>; <span class="id" title="tactic">fail</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">depind</span> <span class="id" title="var">p2</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">v</span>; <span class="id" title="var">Y</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="var">Y</span>; <span class="id" title="tactic">destruct</span> (<span class="id" title="var">z</span> × <span class="id" title="var">z0</span>)%<span class="id" title="var">Z</span>; <span class="id" title="tactic">simpl</span>...<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">assert</span> (<span class="id" title="var">mult_l_eval</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">b2</span>} (<span class="id" title="var">q</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) <span class="id" title="var">v</span> <span class="id" title="var">h</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eval</span> (<span class="id" title="var">mult_l</span> <span class="id" title="var">q</span> (@<span class="id" title="var">mult</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">p1</span>)).2 (<span class="id" title="var">Vector.cons</span> <span class="id" title="var">h</span> <span class="id" title="var">v</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">eval</span> <span class="id" title="var">q</span> (<span class="id" title="var">Vector.cons</span> <span class="id" title="var">h</span> <span class="id" title="var">v</span>) × <span class="id" title="tactic">eval</span> <span class="id" title="var">p1</span> <span class="id" title="var">v</span>)%<span class="id" title="var">Z</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">depind</span> <span class="id" title="var">q</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="var">Y</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHp1</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHq2</span>; <span class="id" title="tactic">auto</span>; <span class="id" title="var">nia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">v</span>; <span class="id" title="var">Y</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="var">Y</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">mult_l_eval</span>...<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">assert</span> (<span class="id" title="var">mult_s_eval</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> {<span class="id" title="var">b2</span>} (<span class="id" title="var">q</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) <span class="id" title="var">v</span> <span class="id" title="var">h</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">mp</span> := <span class="id" title="var">mult_s</span> <span class="id" title="var">q</span> (@<span class="id" title="var">mult</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">p1_1</span>) (@<span class="id" title="var">mult</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">p1_2</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eval</span> <span class="id" title="var">mp</span>.2 (<span class="id" title="var">Vector.cons</span> <span class="id" title="var">h</span> <span class="id" title="var">v</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">eval</span> <span class="id" title="var">q</span> (<span class="id" title="var">Vector.cons</span> <span class="id" title="var">h</span> <span class="id" title="var">v</span>) × (<span class="id" title="tactic">eval</span> <span class="id" title="var">p1_1</span> <span class="id" title="var">v</span> + <span class="id" title="var">h</span> × <span class="id" title="tactic">eval</span> <span class="id" title="var">p1_2</span> (<span class="id" title="var">Vector.cons</span> <span class="id" title="var">h</span> <span class="id" title="var">v</span>)))%<span class="id" title="var">Z</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">depind</span> <span class="id" title="var">q</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="var">Y</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="var">Y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHp1_1</span>, &lt;- <span class="id" title="var">IHp1_2</span>; <span class="id" title="var">Y</span>; <span class="id" title="var">nia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHp1_1</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHq2</span>, &lt;- <span class="id" title="var">IHp1_2</span>; <span class="id" title="tactic">auto</span>; <span class="id" title="var">Y</span>; <span class="id" title="var">nia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">v</span>; <span class="id" title="var">Y</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="var">Y</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">mult_s_eval</span>...<br/>
<span class="id" title="keyword">Qed</span>.<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Rewrite</span> &lt;- @<span class="id" title="var">mult_eval</span> : <span class="id" title="tactic">eval</span>.<br/>
</div>

<div class="doc">
<a id="lab7"></a><h2 class="section">Boolean formulas</h2>


<div class="paragraph"> </div>

  Armed with these definitions, we can define a reflexive tactic that
  solves boolean tautologies using a translation into polynomials on <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Numbers.BinNums.html#Z"><span class="id" title="inductive">Z</span></a></span>.
  We start with the syntax of our formulas, including variables of some type
  <span class="inlinecode"><span class="id" title="var">A</span></span>, constants, conjunction disjunction and negation: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">formula</span> {<span class="id" title="var">A</span>} :=<br/>
| <span class="id" title="var">f_var</span> : <span class="id" title="var">A</span> → <span class="id" title="var">formula</span><br/>
| <span class="id" title="var">f_const</span> : <span class="id" title="var">bool</span> → <span class="id" title="var">formula</span><br/>
| <span class="id" title="var">f_and</span> : <span class="id" title="var">formula</span> → <span class="id" title="var">formula</span> → <span class="id" title="var">formula</span><br/>
| <span class="id" title="var">f_or</span> : <span class="id" title="var">formula</span> → <span class="id" title="var">formula</span> → <span class="id" title="var">formula</span><br/>
| <span class="id" title="var">f_not</span> : <span class="id" title="var">formula</span> → <span class="id" title="var">formula</span>.<br/>

<br/>
</div>

<div class="doc">
The have a straightforward evaluation semantics to booleans, assuming
    an interpretation of the variables into booleans. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">eval_formula</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">v</span> : <span class="id" title="var">A</span> → <span class="id" title="var">bool</span>) (<span class="id" title="var">f</span> : @<span class="id" title="var">formula</span> <span class="id" title="var">A</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">eval_formula</span> <span class="id" title="var">f</span> (<span class="id" title="var">f_var</span> <span class="id" title="var">v</span>)   := <span class="id" title="var">f</span> <span class="id" title="var">v</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">eval_formula</span> <span class="id" title="var">f</span> (<span class="id" title="var">f_const</span> <span class="id" title="var">b</span>) := <span class="id" title="var">b</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">eval_formula</span> <span class="id" title="var">f</span> (<span class="id" title="var">f_and</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>) := <span class="id" title="var">andb</span> (<span class="id" title="var">eval_formula</span> <span class="id" title="var">f</span> <span class="id" title="var">a</span>) (<span class="id" title="var">eval_formula</span> <span class="id" title="var">f</span> <span class="id" title="var">b</span>);<br/>
&nbsp;&nbsp;<span class="id" title="var">eval_formula</span> <span class="id" title="var">f</span> (<span class="id" title="var">f_or</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)  := <span class="id" title="var">orb</span> (<span class="id" title="var">eval_formula</span> <span class="id" title="var">f</span> <span class="id" title="var">a</span>) (<span class="id" title="var">eval_formula</span> <span class="id" title="var">f</span> <span class="id" title="var">b</span>);<br/>
&nbsp;&nbsp;<span class="id" title="var">eval_formula</span> <span class="id" title="var">f</span> (<span class="id" title="var">f_not</span> <span class="id" title="var">v</span>)   := <span class="id" title="var">negb</span> (<span class="id" title="var">eval_formula</span> <span class="id" title="var">f</span> <span class="id" title="var">v</span>).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#close_formula"><span class="id" title="definition">close_formula</span></a></span> allows to obtain a formula with a fixed finite number of free variables from
   a formula with with variables in <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">close_formula</span> : @<span class="id" title="var">formula</span> <span class="id" title="var">nat</span> → { <span class="id" title="var">n</span> : <span class="id" title="var">nat</span> &amp; <span class="id" title="keyword">∀</span> <span class="id" title="var">m</span>, <span class="id" title="var">m</span> ≥ <span class="id" title="var">n</span> → @<span class="id" title="var">formula</span> (<span class="id" title="var">Fin.t</span> <span class="id" title="var">m</span>) }.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">f</span>; <span class="id" title="var">depind</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">unshelve</span> <span class="id" title="tactic">eapply</span> (<span class="id" title="var">S</span> <span class="id" title="var">a</span> ; <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">f_var</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> @<span class="id" title="var">Fin.of_nat_lt</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">p</span> := <span class="id" title="var">a</span>). <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> (<span class="id" title="var">O</span> ; (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">f_const</span> <span class="id" title="var">b</span>)).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">IHf1</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n1</span> <span class="id" title="var">e1</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">IHf2</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n2</span> <span class="id" title="var">e2</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">existT</span> <span class="id" title="var">_</span> (<span class="id" title="var">max</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span>)); <span class="id" title="tactic">intros</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">f_and</span>; [<span class="id" title="tactic">apply</span> <span class="id" title="var">e1</span>|<span class="id" title="tactic">apply</span> <span class="id" title="var">e2</span>]; <span class="id" title="var">nia</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">IHf1</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n1</span> <span class="id" title="var">e1</span>]; <span class="id" title="tactic">destruct</span> <span class="id" title="var">IHf2</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n2</span> <span class="id" title="var">e2</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">existT</span> <span class="id" title="var">_</span> (<span class="id" title="var">max</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span>)); <span class="id" title="tactic">intros</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">f_or</span>; [<span class="id" title="tactic">apply</span> <span class="id" title="var">e1</span>|<span class="id" title="tactic">apply</span> <span class="id" title="var">e2</span>]; <span class="id" title="var">nia</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">IHf</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span> <span class="id" title="var">e</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">existT</span> <span class="id" title="var">_</span> <span class="id" title="var">n</span>); <span class="id" title="tactic">intros</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">f_not</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">e</span>; <span class="id" title="var">nia</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">close_formulas</span> (<span class="id" title="var">f1</span> <span class="id" title="var">f2</span> : @<span class="id" title="var">formula</span> <span class="id" title="var">nat</span>) :<br/>
&nbsp;&nbsp;{ <span class="id" title="var">n</span> : <span class="id" title="var">nat</span> &amp; (@<span class="id" title="var">formula</span> (<span class="id" title="var">Fin.t</span> <span class="id" title="var">n</span>) × @<span class="id" title="var">formula</span> (<span class="id" title="var">Fin.t</span> <span class="id" title="var">n</span>))%<span class="id" title="keyword">type</span> }.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">close_formula</span> <span class="id" title="var">f1</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">n1</span> <span class="id" title="var">e1</span>]; <span class="id" title="tactic">destruct</span> (<span class="id" title="var">close_formula</span> <span class="id" title="var">f2</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">n2</span> <span class="id" title="var">e2</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">existT</span> <span class="id" title="var">_</span> (<span class="id" title="var">max</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span>)); <span class="id" title="tactic">apply</span> <span class="id" title="var">pair</span>; [<span class="id" title="tactic">apply</span> <span class="id" title="var">e1</span>|<span class="id" title="tactic">apply</span> <span class="id" title="var">e2</span>]; <span class="id" title="var">nia</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Definitions of constant 0 <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_zero"><span class="id" title="definition">poly_zero</span></a></span> and 1 <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_one"><span class="id" title="definition">poly_one</span></a></span> polynomials along with variable polynomials
    <span class="inlinecode"><a class="idref" href="http://github.com/mattam82/Coq-Equations/tree/main/Equations.Examples.polynomials.html#poly_var"><span class="id" title="definition">poly_var</span></a></span> and corresponding evaluation lemmas 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">poly_zero</span> {<span class="id" title="var">n</span>} : <span class="id" title="var">poly</span> <span class="id" title="var">true</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span>   ⇒ <span class="id" title="var">poly_z</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m</span> ⇒ <span class="id" title="var">poly_l</span> <span class="id" title="var">poly_zero</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">zero_eval</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">v</span>, 0%<span class="id" title="var">Z</span> = <span class="id" title="tactic">eval</span> (@<span class="id" title="var">poly_zero</span> <span class="id" title="var">n</span>) <span class="id" title="var">v</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">poly_z_eval</span>; <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Rewrite</span> &lt;- @<span class="id" title="var">zero_eval</span> : <span class="id" title="tactic">eval</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">poly_one</span> {<span class="id" title="var">n</span>} : <span class="id" title="var">poly</span> <span class="id" title="var">false</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span>   ⇒ <span class="id" title="var">poly_c</span> 1%<span class="id" title="var">Z</span> <span class="id" title="var">I</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m</span> ⇒ <span class="id" title="var">poly_l</span> <span class="id" title="var">poly_one</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">one_eval</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">v</span>, 1%<span class="id" title="var">Z</span> = <span class="id" title="tactic">eval</span> (@<span class="id" title="var">poly_one</span> <span class="id" title="var">n</span>) <span class="id" title="var">v</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">depind</span> <span class="id" title="var">n</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">v</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="tactic">eval</span>; <span class="id" title="tactic">auto</span>. <span class="id" title="keyword">Qed</span>.<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Rewrite</span> &lt;- @<span class="id" title="var">one_eval</span> : <span class="id" title="tactic">eval</span>.<br/>

<br/>
</div>

<div class="doc">
We define an injection of variables represented as indices in <span class="inlinecode"><span class="id" title="var">Fin.t</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> into
    non-null polynoms of <span class="inlinecode"><span class="id" title="var">n</span></span> variables: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">poly_var</span> {<span class="id" title="var">n</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">Fin.t</span> <span class="id" title="var">n</span>) : <span class="id" title="var">poly</span> <span class="id" title="var">false</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">poly_var</span> <span class="id" title="var">Fin.F1</span>     := <span class="id" title="var">poly_s</span> <span class="id" title="var">poly_zero</span> <span class="id" title="var">poly_one</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">poly_var</span> (<span class="id" title="var">Fin.FS</span> <span class="id" title="var">f</span>) := <span class="id" title="var">poly_l</span> (<span class="id" title="var">poly_var</span> <span class="id" title="var">f</span>).<br/>

<br/>
</div>

<div class="doc">
We can show that evaluation of the corresponding polynomial corresponds to
    simply fetching the value at the index in the valuation. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">var_eval</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span> <span class="id" title="var">v</span>, <span class="id" title="var">Vector.nth</span> <span class="id" title="var">v</span> <span class="id" title="var">f</span> = <span class="id" title="tactic">eval</span> (@<span class="id" title="var">poly_var</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span>) <span class="id" title="var">v</span>.<br/>
<span class="id" title="keyword">Proof</span> <span class="id" title="keyword">with</span> <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">poly_var</span> <span class="id" title="tactic">eval</span> <span class="id" title="tactic">in</span> *; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">zarith</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">f</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">v</span>; <span class="id" title="tactic">intros</span>...<br/>
<span class="id" title="keyword">Qed</span>.<br/>
#[<span class="id" title="var">local</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Rewrite</span> &lt;- @<span class="id" title="var">var_eval</span> : <span class="id" title="tactic">eval</span>.<br/>

<br/>
</div>

<div class="doc">
Finally, we explain our interpretation of formulas as polynomials: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">poly_of_formula</span> {<span class="id" title="var">n</span>} (<span class="id" title="var">f</span> : @<span class="id" title="var">formula</span> (<span class="id" title="var">Fin.t</span> <span class="id" title="var">n</span>)) : { <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> &amp; <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span> } :=<br/>
&nbsp;&nbsp;<span class="id" title="var">poly_of_formula</span> (<span class="id" title="var">f_var</span> <span class="id" title="var">v</span>)       := <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_var</span> <span class="id" title="var">v</span>);<br/>
&nbsp;&nbsp;<span class="id" title="var">poly_of_formula</span> (<span class="id" title="var">f_const</span> <span class="id" title="var">false</span>) := <span class="id" title="var">apoly</span> <span class="id" title="var">poly_zero</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">poly_of_formula</span> (<span class="id" title="var">f_const</span> <span class="id" title="var">true</span>)  := <span class="id" title="var">apoly</span> <span class="id" title="var">poly_one</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">poly_of_formula</span> (<span class="id" title="var">f_not</span> <span class="id" title="var">a</span>)       := <span class="id" title="var">plus</span> <span class="id" title="var">poly_one</span> (<span class="id" title="var">poly_neg</span> (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">a</span>).2);<br/>
&nbsp;&nbsp;<span class="id" title="var">poly_of_formula</span> (<span class="id" title="var">f_and</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)     := <span class="id" title="var">mult</span> (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">a</span>).2 (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">b</span>).2;<br/>
&nbsp;&nbsp;<span class="id" title="var">poly_of_formula</span> (<span class="id" title="var">f_or</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)      := <span class="id" title="var">plus</span> (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">a</span>).2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">plus</span> (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">b</span>).2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">poly_neg</span> (<span class="id" title="var">mult</span> (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">a</span>).2 (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">b</span>).2).2)).2.<br/>

<br/>
</div>

<div class="doc">
The central theorem is that evaluating the formula in some valuation
    is the same as evaluating the translated polynomial. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">poly_of_formula_eval</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>} (<span class="id" title="var">f</span> : @<span class="id" title="var">formula</span> (<span class="id" title="var">Fin.t</span> <span class="id" title="var">n</span>)) (<span class="id" title="var">v</span> : <span class="id" title="var">Vector.t</span> <span class="id" title="var">bool</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">if</span> <span class="id" title="var">eval_formula</span> (<span class="id" title="var">Vector.nth</span> <span class="id" title="var">v</span>) <span class="id" title="var">f</span> <span class="id" title="keyword">then</span> 1%<span class="id" title="var">Z</span> <span class="id" title="keyword">else</span> 0%<span class="id" title="var">Z</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eval</span> (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">f</span>).2 (<span class="id" title="var">Vector.map</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">bool</span> ⇒ <span class="id" title="keyword">if</span> <span class="id" title="var">x</span> <span class="id" title="keyword">then</span> 1%<span class="id" title="var">Z</span> <span class="id" title="keyword">else</span> 0%<span class="id" title="var">Z</span>) <span class="id" title="var">v</span>).<br/>

<br/>
</div>

<div class="doc">
From this, we can derive that two boolean formulas are equivalent if
    the translated polynomials are themselves <i>syntactically</i> equal,
    thanks to their canonical representation. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">correctness_heyting</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>} (<span class="id" title="var">f1</span> <span class="id" title="var">f2</span> : @<span class="id" title="var">formula</span> (<span class="id" title="var">Fin.t</span> <span class="id" title="var">n</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">f1</span> = <span class="id" title="var">poly_of_formula</span> <span class="id" title="var">f2</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">v</span>, <span class="id" title="var">eval_formula</span> (<span class="id" title="var">Vector.nth</span> <span class="id" title="var">v</span>) <span class="id" title="var">f1</span> = <span class="id" title="var">eval_formula</span> (<span class="id" title="var">Vector.nth</span> <span class="id" title="var">v</span>) <span class="id" title="var">f2</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span> <span class="id" title="var">H</span> <span class="id" title="var">v</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H1</span> := <span class="id" title="var">poly_of_formula_eval</span> <span class="id" title="var">f1</span> <span class="id" title="var">v</span>); <span class="id" title="tactic">assert</span> (<span class="id" title="var">H2</span> := <span class="id" title="var">poly_of_formula_eval</span> <span class="id" title="var">f2</span> <span class="id" title="var">v</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">eval_formula</span> (<span class="id" title="var">Vector.nth</span> <span class="id" title="var">v</span>) <span class="id" title="var">f1</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">b1</span>; <span class="id" title="var">remember</span> (<span class="id" title="var">eval_formula</span> (<span class="id" title="var">Vector.nth</span> <span class="id" title="var">v</span>) <span class="id" title="var">f2</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">b2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>; <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H1</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b1</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">b2</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> *; (<span class="id" title="tactic">discriminate</span> || <span class="id" title="tactic">auto</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab8"></a><h3 class="section">Completeness</h3>


<div class="paragraph"> </div>

  For which theory do we have completeness? If you were attentive you might
  have guessed that the encodings of disjunction and conjunction are only
  complete for heyting boolean algebras but not classical boolean algebra,
  where negation is involutive.

<div class="paragraph"> </div>

  One can avoid this problem by doing a reduction transformation on polynomials.
  The interested reader can look at the development for that part.
  Completeness can be derived for the reducing version of the translation.
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">reduce_aux</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b1</span>} (<span class="id" title="var">p1</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b1</span> <span class="id" title="var">n</span>) {<span class="id" title="var">b2</span>} (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) : { <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> &amp; <span class="id" title="var">poly</span> <span class="id" title="var">b</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) } :=<br/>
<span class="id" title="var">reduce_aux</span> <span class="id" title="var">p1</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">p2</span>) := <span class="id" title="var">poly_l_or_s</span> <span class="id" title="var">p1</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">p2</span>);<br/>
<span class="id" title="var">reduce_aux</span> <span class="id" title="var">p1</span> (<span class="id" title="var">poly_s</span> <span class="id" title="var">p2_1</span> <span class="id" title="var">p2_2</span>) := <span class="id" title="var">poly_l_or_s</span> <span class="id" title="var">p1</span> (<span class="id" title="var">plus</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">p2_1</span>) <span class="id" title="var">p2_2</span>).2.<br/>

<br/>
<span class="id" title="keyword">Equations</span> <span class="id" title="var">reduce</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span>) : { <span class="id" title="var">b</span> : <span class="id" title="var">bool</span> &amp; <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span> } :=<br/>
&nbsp;&nbsp;<span class="id" title="var">reduce</span> <span class="id" title="var">poly_z</span>       := <span class="id" title="var">apoly</span> <span class="id" title="var">poly_z</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">reduce</span> (<span class="id" title="var">poly_c</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) := <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_c</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>);<br/>
&nbsp;&nbsp;<span class="id" title="var">reduce</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">p</span>)   := <span class="id" title="var">apoly</span> (<span class="id" title="var">poly_l</span> (<span class="id" title="var">reduce</span> <span class="id" title="var">p</span>).2);<br/>
&nbsp;&nbsp;<span class="id" title="var">reduce</span> (<span class="id" title="var">poly_s</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span>) := <span class="id" title="var">reduce_aux</span> (<span class="id" title="var">reduce</span> <span class="id" title="var">p</span>).2 (<span class="id" title="var">reduce</span> <span class="id" title="var">q</span>).2.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">reduce_eval</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span>) (<span class="id" title="var">v</span> : <span class="id" title="var">Vector.t</span> <span class="id" title="var">bool</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eval</span> <span class="id" title="var">p</span> (<span class="id" title="var">Vector.map</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">bool</span> ⇒ <span class="id" title="keyword">if</span> <span class="id" title="var">x</span> <span class="id" title="keyword">then</span> 1%<span class="id" title="var">Z</span> <span class="id" title="keyword">else</span> 0%<span class="id" title="var">Z</span>) <span class="id" title="var">v</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eval</span> (<span class="id" title="var">reduce</span> <span class="id" title="var">p</span>).2 (<span class="id" title="var">Vector.map</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">bool</span> ⇒ <span class="id" title="keyword">if</span> <span class="id" title="var">x</span> <span class="id" title="keyword">then</span> 1%<span class="id" title="var">Z</span> <span class="id" title="keyword">else</span> 0%<span class="id" title="var">Z</span>) <span class="id" title="var">v</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">YY</span> := <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">reduce</span> <span class="id" title="var">reduce_aux</span> <span class="id" title="tactic">eval</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">depind</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">v</span>; <span class="id" title="var">YY</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHp1</span>, (<span class="id" title="var">IHp2</span> (<span class="id" title="var">Vector.cons</span> <span class="id" title="var">h</span> <span class="id" title="var">v</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">reduce</span> <span class="id" title="var">p2</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">P</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">P</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">bP</span> <span class="id" title="var">P</span>]. <span class="id" title="tactic">simpl</span>. <span class="id" title="var">depelim</span> <span class="id" title="var">P</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="var">YY</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">h</span>; <span class="id" title="var">nia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">is_reduced</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">b</span>} {<span class="id" title="var">n</span>}, <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span> → <span class="id" title="keyword">Prop</span> :=<br/>
| <span class="id" title="var">is_reduced_z</span> : <span class="id" title="var">is_reduced</span> <span class="id" title="var">poly_z</span><br/>
| <span class="id" title="var">is_reduced_c</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">z</span>} {<span class="id" title="var">i</span>}, <span class="id" title="var">is_reduced</span> (<span class="id" title="var">poly_c</span> <span class="id" title="var">z</span> <span class="id" title="var">i</span>)<br/>
| <span class="id" title="var">is_reduced_l</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">b</span>} {<span class="id" title="var">n</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span>), <span class="id" title="var">is_reduced</span> <span class="id" title="var">p</span> → <span class="id" title="var">is_reduced</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">p</span>)<br/>
| <span class="id" title="var">is_reduced_s</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">b1</span>} {<span class="id" title="var">n</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b1</span> <span class="id" title="var">n</span>) (<span class="id" title="var">q</span> : <span class="id" title="var">poly</span> <span class="id" title="var">false</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">is_reduced</span> <span class="id" title="var">p</span> → <span class="id" title="var">is_reduced</span> <span class="id" title="var">q</span> → <span class="id" title="var">is_reduced</span> (<span class="id" title="var">poly_s</span> <span class="id" title="var">p</span> (<span class="id" title="var">poly_l</span> <span class="id" title="var">q</span>))<br/>
.<br/>
<span class="id" title="keyword">Derive</span> <span class="id" title="var">Signature</span> <span class="id" title="keyword">for</span> <span class="id" title="var">is_reduced</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">is_reduced_compat_plus</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b1</span>} (<span class="id" title="var">p1</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b1</span> <span class="id" title="var">n</span>) (<span class="id" title="var">Hp1</span> : <span class="id" title="var">is_reduced</span> <span class="id" title="var">p1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">b2</span>} (<span class="id" title="var">p2</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b2</span> <span class="id" title="var">n</span>) (<span class="id" title="var">Hp2</span> : <span class="id" title="var">is_reduced</span> <span class="id" title="var">p2</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">is_reduced</span> (<span class="id" title="var">plus</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>).2.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">depind</span> <span class="id" title="var">Hp1</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">Hp2</span>; <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">plus</span>; <span class="id" title="tactic">unfold</span> <span class="id" title="var">apoly</span>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">z</span>+<span class="id" title="var">z0</span>)%<span class="id" title="var">Z</span> <span class="id" title="keyword">as</span> <span class="id" title="var">Z</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">Z</span>; <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHHp1_2</span> <span class="id" title="var">_</span> <span class="id" title="var">q0</span> <span class="id" title="var">Hp2_2</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">plus</span> <span class="id" title="var">q</span> <span class="id" title="var">q0</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">Q</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">Q</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">bQ</span> <span class="id" title="var">Q</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">bQ</span>; <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">auto</span>. <span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">is_reduced_compat_neg</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b1</span>} (<span class="id" title="var">p1</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b1</span> <span class="id" title="var">n</span>) (<span class="id" title="var">Hp1</span> : <span class="id" title="var">is_reduced</span> <span class="id" title="var">p1</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">is_reduced</span> (<span class="id" title="var">poly_neg</span> <span class="id" title="var">p1</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="var">depind</span> <span class="id" title="var">Hp1</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">destruct</span> <span class="id" title="var">z</span>, <span class="id" title="var">i</span>; <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">poly_neg</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">is_reduced_ok</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">b</span>} {<span class="id" title="var">n</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span>), <span class="id" title="var">is_reduced</span> (<span class="id" title="var">reduce</span> <span class="id" title="var">p</span>).2.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">depind</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">reduce</span> <span class="id" title="var">reduce_aux</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">reduce</span> <span class="id" title="var">p2</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">P2</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">P2</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">bP2</span> <span class="id" title="var">P2</span>]; <span class="id" title="var">depelim</span> <span class="id" title="var">P2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">bP2</span>; <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">auto</span>. <span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">auto</span>. <span class="id" title="var">depelim</span> <span class="id" title="var">IHp2</span>. <span class="id" title="tactic">auto</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="var">depelim</span> <span class="id" title="var">IHp2</span>. <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">reduce_aux</span> <span class="id" title="var">plus</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">apoly</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">R</span> := <span class="id" title="var">is_reduced_compat_plus</span> <span class="id" title="var">_</span> <span class="id" title="var">IHp2_1</span> <span class="id" title="var">_</span> <span class="id" title="var">IHp2_2</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">plus</span> <span class="id" title="var">P2_1</span> <span class="id" title="var">q</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">P3</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">P3</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">bP3</span> <span class="id" title="var">P3</span>]. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> ×.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">bP3</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">red_ok</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>} {<span class="id" title="var">b</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">poly</span> <span class="id" title="var">b</span> <span class="id" title="var">n</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">is_reduced</span> <span class="id" title="var">p</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">v</span>, <span class="id" title="tactic">eval</span> <span class="id" title="var">p</span> (<span class="id" title="var">Vector.map</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">bool</span> ⇒ <span class="id" title="keyword">if</span> <span class="id" title="var">x</span> <span class="id" title="keyword">then</span> 1%<span class="id" title="var">Z</span> <span class="id" title="keyword">else</span> 0%<span class="id" title="var">Z</span>) <span class="id" title="var">v</span>) = 0%<span class="id" title="var">Z</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">b</span> = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">b</span> <span class="id" title="var">p</span> <span class="id" title="var">Hp</span> <span class="id" title="var">H</span>; <span class="id" title="var">depind</span> <span class="id" title="var">Hp</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> <span class="id" title="var">Vector.nil</span>); <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="tactic">eval</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">z</span>, <span class="id" title="var">i</span>; <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">IHHp</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">v</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> (<span class="id" title="var">Vector.cons</span> <span class="id" title="var">false</span> <span class="id" title="var">v</span>)). <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="tactic">eval</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">assert</span> (<span class="id" title="var">b1</span> = <span class="id" title="var">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">IHHp1</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">v</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> (<span class="id" title="var">Vector.cons</span> <span class="id" title="var">false</span> <span class="id" title="var">v</span>)). <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="tactic">eval</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Z.add_0_r</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHHp2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">v</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> (<span class="id" title="var">Vector.cons</span> <span class="id" title="var">true</span> <span class="id" title="var">v</span>)). <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="tactic">eval</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">poly_z_eval</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="var">nia</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We have completeness for this form: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">correctness_classical</span> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">n</span>} (<span class="id" title="var">f1</span> <span class="id" title="var">f2</span> : @<span class="id" title="var">formula</span> (<span class="id" title="var">Fin.t</span> <span class="id" title="var">n</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reduce</span> (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">f1</span>).2 = <span class="id" title="var">reduce</span> (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">f2</span>).2 ↔<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">v</span>, <span class="id" title="var">eval_formula</span> (<span class="id" title="var">Vector.nth</span> <span class="id" title="var">v</span>) <span class="id" title="var">f1</span> = <span class="id" title="var">eval_formula</span> (<span class="id" title="var">Vector.nth</span> <span class="id" title="var">v</span>) <span class="id" title="var">f2</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span>; <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span> <span class="id" title="var">v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H1</span> := <span class="id" title="var">poly_of_formula_eval</span> <span class="id" title="var">f1</span> <span class="id" title="var">v</span>); <span class="id" title="tactic">assert</span> (<span class="id" title="var">H2</span> := <span class="id" title="var">poly_of_formula_eval</span> <span class="id" title="var">f2</span> <span class="id" title="var">v</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">reduce_eval</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">reduce_eval</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">eval_formula</span> (<span class="id" title="var">Vector.nth</span> <span class="id" title="var">v</span>) <span class="id" title="var">f1</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">b1</span>; <span class="id" title="var">remember</span> (<span class="id" title="var">eval_formula</span> (<span class="id" title="var">Vector.nth</span> <span class="id" title="var">v</span>) <span class="id" title="var">f2</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">b2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H1</span>; <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H1</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b1</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">b2</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> *; (<span class="id" title="tactic">discriminate</span> || <span class="id" title="tactic">auto</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> ((<span class="id" title="var">plus</span> (<span class="id" title="var">reduce</span> (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">f1</span>).2).2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">poly_neg</span> (<span class="id" title="var">reduce</span> (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">f2</span>).2).2)).1 = <span class="id" title="var">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">red_ok</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">p</span> := (<span class="id" title="var">plus</span> (<span class="id" title="var">reduce</span> (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">f1</span>).2).2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">poly_neg</span> (<span class="id" title="var">reduce</span> (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">f2</span>).2).2)).2).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="tactic">auto</span> <span class="id" title="keyword">using</span> <span class="id" title="var">is_reduced_compat_plus</span>, <span class="id" title="var">is_reduced_ok</span>, <span class="id" title="var">is_reduced_compat_neg</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="tactic">intro</span>; <span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="tactic">eval</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H1</span> := <span class="id" title="var">poly_of_formula_eval</span> <span class="id" title="var">f1</span> <span class="id" title="var">v</span>); <span class="id" title="tactic">assert</span> (<span class="id" title="var">H2</span> := <span class="id" title="var">poly_of_formula_eval</span> <span class="id" title="var">f2</span> <span class="id" title="var">v</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- !<span class="id" title="var">reduce_eval</span>, &lt;- <span class="id" title="var">H1</span>, &lt;- <span class="id" title="var">H2</span>, (<span class="id" title="var">H</span> <span class="id" title="var">v</span>); <span class="id" title="var">nia</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">poly_diff_z_eq</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">reduce</span> (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">f1</span>).2) <span class="id" title="keyword">as</span> <span class="id" title="var">P1</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">P1</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">bP1</span> <span class="id" title="var">P1</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">reduce</span> (<span class="id" title="var">poly_of_formula</span> <span class="id" title="var">f2</span>).2) <span class="id" title="keyword">as</span> <span class="id" title="var">P2</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">P2</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">bP2</span> <span class="id" title="var">P2</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">bP1</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">bP2</span>; <span class="id" title="tactic">auto</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H0</span>; <span class="id" title="var">depelim</span> <span class="id" title="var">H0</span>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
One can check that all definitions here are axiom free, and only the proofs
    which depend on unfolding lemmas use the <span class="inlinecode"><span class="id" title="var">functional_extensionality_dep</span></span> axiom. 
<div class="paragraph"> </div>

<a id="lab9"></a><h3 class="section">Reflexive tactic</h3>


<div class="paragraph"> </div>

  From this it is possible to derive a tactic for checking equivalence of boolean
  formulas. We skip the standard reification machinery and check on a few examples
  that indeed our tactic computes. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">list_add</span> <span class="id" title="var">a</span> <span class="id" title="var">l</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="keyword">rec</span> <span class="id" title="var">aux</span> <span class="id" title="var">a</span> <span class="id" title="var">l</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="keyword">constr</span>:((<span class="id" title="var">n</span>, <span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">l</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> <span class="id" title="var">a</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="keyword">constr</span>:((<span class="id" title="var">n</span>, <span class="id" title="var">l</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">l</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">aux</span> <span class="id" title="var">a</span> <span class="id" title="var">l</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="keyword">with</span> (?<span class="id" title="var">n</span>, ?<span class="id" title="var">l</span>) ⇒ <span class="id" title="keyword">constr</span>:((<span class="id" title="var">n</span>, <span class="id" title="var">cons</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span>)) <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">aux</span> <span class="id" title="var">a</span> <span class="id" title="var">l</span> 0.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">vector_of_list</span> <span class="id" title="var">l</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="keyword">constr</span>:(<span class="id" title="var">Vector.nil</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">cons</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">xs</span> ⇒ <span class="id" title="keyword">constr</span>:(<span class="id" title="var">Vector.cons</span> <span class="id" title="var">x</span> <span class="id" title="var">xs</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Reify boolean formulas with variables in <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/doc/V9.0+rc1/stdlib//Corelib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">read_formula</span> <span class="id" title="var">f</span> <span class="id" title="var">l</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">f</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">true</span> ⇒ <span class="id" title="keyword">constr</span>:((@<span class="id" title="var">f_const</span> <span class="id" title="var">nat</span> <span class="id" title="var">true</span>, <span class="id" title="var">l</span>))<br/>
&nbsp;&nbsp;| <span class="id" title="var">false</span> ⇒ <span class="id" title="keyword">constr</span>:((@<span class="id" title="var">f_const</span> <span class="id" title="var">nat</span> <span class="id" title="var">false</span>, <span class="id" title="var">l</span>))<br/>
&nbsp;&nbsp;| <span class="id" title="var">orb</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">y</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">read_formula</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span> (?<span class="id" title="var">x'</span>, ?<span class="id" title="var">l'</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">read_formula</span> <span class="id" title="var">y</span> <span class="id" title="var">l'</span> <span class="id" title="keyword">with</span> (?<span class="id" title="var">y'</span>, ?<span class="id" title="var">l''</span>) ⇒ <span class="id" title="keyword">constr</span>:((<span class="id" title="var">f_or</span> <span class="id" title="var">x'</span> <span class="id" title="var">y'</span>, <span class="id" title="var">l''</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">andb</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">y</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">read_formula</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span> (?<span class="id" title="var">x'</span>, ?<span class="id" title="var">l'</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">read_formula</span> <span class="id" title="var">y</span> <span class="id" title="var">l'</span> <span class="id" title="keyword">with</span> (?<span class="id" title="var">y'</span>, ?<span class="id" title="var">l''</span>) ⇒ <span class="id" title="keyword">constr</span>:((<span class="id" title="var">f_and</span> <span class="id" title="var">x'</span> <span class="id" title="var">y'</span>, <span class="id" title="var">l''</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">negb</span> ?<span class="id" title="var">x</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">read_formula</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span> (?<span class="id" title="var">x'</span>, ?<span class="id" title="var">l'</span>) ⇒ <span class="id" title="keyword">constr</span>:((<span class="id" title="var">f_not</span> <span class="id" title="var">x'</span>, <span class="id" title="var">l'</span>)) <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">list_add</span> <span class="id" title="var">f</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span> (?<span class="id" title="var">n</span>, ?<span class="id" title="var">l'</span>) ⇒ <span class="id" title="keyword">constr</span>:((<span class="id" title="var">f_var</span> <span class="id" title="var">n</span>, <span class="id" title="var">l'</span>)) <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">read_formulas</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">read_formula</span> <span class="id" title="var">x</span> (@<span class="id" title="var">nil</span> <span class="id" title="var">bool</span>) <span class="id" title="keyword">with</span> (?<span class="id" title="var">x'</span>, ?<span class="id" title="var">l</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">read_formula</span> <span class="id" title="var">y</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span> (?<span class="id" title="var">y'</span>, ?<span class="id" title="var">l'</span>) ⇒ <span class="id" title="keyword">constr</span>:(((<span class="id" title="var">x'</span>, <span class="id" title="var">y'</span>), <span class="id" title="var">l'</span>))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span> <span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The final reflexive tactic, taking either of the correctness lemmas as argument. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">bool_tauto_with</span> <span class="id" title="var">f</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| [ |- ?<span class="id" title="var">x</span> = ?<span class="id" title="var">y</span> ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">read_formulas</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ((?<span class="id" title="var">x'</span>, ?<span class="id" title="var">y'</span>), ?<span class="id" title="var">l</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">ln</span> := <span class="id" title="tactic">fresh</span> "l" <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">xyn</span> := <span class="id" title="tactic">fresh</span> "xy" <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">nn</span> := <span class="id" title="tactic">fresh</span> "n" <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">xn</span> := <span class="id" title="tactic">fresh</span> "x" <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">yn</span> := <span class="id" title="tactic">fresh</span> "y" <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">vector_of_list</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span> ?<span class="id" title="var">lv</span> ⇒ <span class="id" title="tactic">pose</span> (<span class="id" title="var">ln</span> := <span class="id" title="var">lv</span>) <span class="id" title="keyword">end</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">xyn</span> := <span class="id" title="var">close_formulas</span> <span class="id" title="var">x'</span> <span class="id" title="var">y'</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">n</span> := <span class="id" title="var">xyn</span>.1); <span class="id" title="tactic">pose</span> (<span class="id" title="var">xn</span> := <span class="id" title="var">fst</span> <span class="id" title="var">xyn</span>.2); <span class="id" title="tactic">pose</span> (<span class="id" title="var">yn</span> := <span class="id" title="var">snd</span> <span class="id" title="var">xyn</span>.2);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="tactic">in</span> <span class="id" title="var">xyn</span>, <span class="id" title="var">n</span>, <span class="id" title="var">xn</span>, <span class="id" title="var">yn</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <span class="id" title="var">eval_formula</span> (<span class="id" title="var">Vector.nth</span> <span class="id" title="var">ln</span>) <span class="id" title="var">xn</span> = <span class="id" title="var">eval_formula</span> (<span class="id" title="var">Vector.nth</span> <span class="id" title="var">ln</span>) <span class="id" title="var">yn</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="id" title="tactic">apply</span> <span class="id" title="var">f</span>; <span class="id" title="keyword">vm_compute</span>; <span class="id" title="tactic">reflexivity</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">exact</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Examples 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>, <span class="id" title="var">andb</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> = <span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">bool_tauto_with</span> @<span class="id" title="var">correctness_heyting</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>, <span class="id" title="var">andb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">a</span>) (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>) = <span class="id" title="var">negb</span> (<span class="id" title="var">orb</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">bool_tauto_with</span> @<span class="id" title="var">correctness_heyting</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>, <span class="id" title="var">orb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">a</span>) (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>) = <span class="id" title="var">negb</span> (<span class="id" title="var">andb</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">bool_tauto_with</span> @<span class="id" title="var">correctness_heyting</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">neg_involutive</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span>, <span class="id" title="var">orb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">a</span>) <span class="id" title="var">a</span> = <span class="id" title="var">true</span>.<br/>
<span class="id" title="var">Fail</span> <span class="id" title="var">bool_tauto_with</span> @<span class="id" title="var">correctness_heyting</span>.<br/>
<span class="id" title="var">bool_tauto_with</span> @<span class="id" title="var">correctness_classical</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>